{
  "tasks": [
    {
      "id": 1,
      "title": "Setup Project Repository and Docker Environment",
      "description": "Initialize the project repository with necessary Docker configuration for containerization of the backend API and PostgreSQL database.",
      "status": "done",
      "dependencies": [],
      "priority": "high",
      "details": "Create a new Git repository. Set up a Docker Compose file that defines services for the FastAPI backend and PostgreSQL database. Create a Dockerfile for the API container based on Python with proper installation of dependencies from requirements.txt. Use the official PostgreSQL image configured through environment variables. Configure environment variables for database credentials and other sensitive information. Set up Docker volumes for PostgreSQL data persistence. Define appropriate networks in docker-compose.yml to facilitate communication between services.",
      "testStrategy": "Verify Docker Compose successfully builds and runs both containers. Ensure the API container can connect to the database container. Confirm data persistence by restarting containers and checking if data remains. Test that the FastAPI service can properly access the PostgreSQL database through the defined Docker network.",
      "subtasks": [
        {
          "id": "1.1",
          "title": "Create Dockerfile for FastAPI API",
          "description": "Create a Dockerfile using Python as the base image and properly installing dependencies from requirements.txt",
          "status": "done"
        },
        {
          "id": "1.2",
          "title": "Configure PostgreSQL container",
          "description": "Use the official PostgreSQL image and configure it with appropriate environment variables",
          "status": "done"
        },
        {
          "id": "1.3",
          "title": "Create docker-compose.yml",
          "description": "Set up docker-compose.yml with services for API and DB, networks for inter-service communication, and volumes for data persistence",
          "status": "done"
        }
      ]
    },
    {
      "id": 2,
      "title": "Database Schema Design and Implementation",
      "description": "Design and implement the PostgreSQL database schema to support the application's data requirements.",
      "status": "done",
      "dependencies": [
        1
      ],
      "priority": "high",
      "details": "Create database schemas for the SDP system with the following key tables:\n\n1. Companies - Base organizational entity\n2. Offices - Locations belonging to companies\n3. Users - All system users (patients, chiropractors, office managers, billing admins)\n4. Roles - User role definitions\n5. TherapyPlans - Treatment plans created by chiropractors\n6. PlanExercises - Exercises included in therapy plans\n7. PlanAssignments - Assignment of plans to patients\n8. Progress - Patient progress tracking\n9. Branding - Company/office branding information\n\nImplement the following relationships:\n- Company -> Offices (one-to-many)\n- Office -> Users (one-to-many)\n- User (chiropractor) -> TherapyPlans (one-to-many)\n- TherapyPlan -> PlanExercises/PlanAssignments (one-to-many)\n- PlanAssignment -> Progress (one-to-many)\n\nSet up migrations for schema changes. Configure PostgreSQL with appropriate indexes and constraints. Initial schema may be implemented via manual migration.",
      "testStrategy": "Write and execute database migration tests. Verify all required tables (Companies, Offices, Users, Roles, TherapyPlans, PlanExercises, PlanAssignments, Progress, Branding) are created with correct relationships. Test CRUD operations on each table to ensure proper functionality. Validate relationship constraints between entities (e.g., cascading deletes where appropriate)."
    },
    {
      "id": 3,
      "title": "FastAPI Backend Setup and Authentication with HIPAA Compliance",
      "description": "Set up the FastAPI backend with authentication endpoints for both web and mobile applications, ensuring HIPAA compliance for all data handling.",
      "status": "done",
      "dependencies": [
        2
      ],
      "priority": "high",
      "details": "Initialize FastAPI application with proper project structure. Implement JWT-based authentication system for secure sessions with encryption in transit and at rest. Create the following authentication endpoints:\n1. POST /auth/login - Accept email and password, return access_token\n2. POST /auth/register - Accept name, email, password, role_id, office_id; return user_id (restricted endpoint)\n3. POST /auth/associate - Accept join_code; return chiro_id and office_id\n\nImplement role-based access control for different user types (chiropractor, office manager, billing admin, patient) following principle of least privilege. Set up middleware for authentication and authorization with detailed audit logging. Connect to database using containerized connection string with encrypted connections. Ensure HTTPS implementation with TLS 1.2+ for transit encryption. Implement automatic session timeouts to protect ePHI. Add detailed audit logging for all authentication events including login attempts, successes, and failures.",
      "testStrategy": "Write unit tests for authentication endpoints with HIPAA compliance verification. Test JWT token generation, validation, and encryption. Verify role-based access restrictions work correctly with proper audit logging. Test user registration and login flows with security controls. Specifically test each endpoint:\n- POST /auth/login\n- POST /auth/register\n- POST /auth/associate\n\nVerify secure HTTPS connections with TLS 1.2+ are working properly. Test database connectivity using containerized connection string with encryption. Validate audit logging captures all required HIPAA information. Test session timeout functionality. Verify encryption of sensitive data both in transit and at rest."
    },
    {
      "id": 4,
      "title": "User Management API Endpoints with HIPAA Compliance",
      "description": "Implement API endpoints for managing users (patients, chiropractors, office managers) within the system with HIPAA-compliant data handling.",
      "status": "done",
      "dependencies": [
        3
      ],
      "priority": "high",
      "details": "Create CRUD endpoints for user management with encryption for ePHI at rest and in transit. Implement endpoints for adding/removing patients associated with chiropractors with detailed audit logging. Develop endpoints for managing chiropractor accounts within an office with RBAC controls. Add functionality for generating unique join codes for patients. Implement proper permission checks based on user roles following principle of least privilege. Define and implement self-service account management endpoints: GET /users/me for retrieving user details and PUT /users/me for updating name, email, and password with audit logging. Implement Role-Based Access Control (RBAC) for different user roles (chiropractor, office_manager, billing, patient) based on the Roles table. Ensure all operations involving ePHI are logged in detail for HIPAA compliance. Implement data minimization practices to limit ePHI exposure according to the Privacy Rule.",
      "testStrategy": "Test each endpoint with various role permissions and verify proper audit logging. Verify proper error handling for unauthorized access with security controls. Test join code generation and validation with encryption. Ensure proper data validation for user creation and updates with HIPAA compliance. Test the GET /users/me and PUT /users/me endpoints with different user roles to verify correct data access and update capabilities with audit trails. Validate RBAC implementation by testing access restrictions for each user role type. Verify encryption of ePHI both in transit and at rest. Test that audit logs capture all required HIPAA information including who accessed what data and when.",
      "subtasks": [
        {
          "id": 4.1,
          "title": "Implement GET /users/me endpoint",
          "description": "Create an endpoint that returns the authenticated user's details",
          "status": "done"
        },
        {
          "id": 4.2,
          "title": "Implement PUT /users/me endpoint",
          "description": "Create an endpoint that allows users to update their name, email, and password",
          "status": "done"
        },
        {
          "id": 4.3,
          "title": "Implement RBAC for user roles",
          "description": "Set up role-based access control for different user types (chiropractor, office_manager, billing, patient) using the Roles table",
          "status": "done"
        },
        {
          "id": 4.4,
          "title": "Add HIPAA-compliant audit logging",
          "description": "Implement detailed audit logging for all user management operations involving ePHI",
          "status": "done"
        },
        {
          "id": 4.5,
          "title": "Implement data encryption",
          "description": "Add encryption for all ePHI at rest and in transit",
          "status": "done"
        },
        {
          "id": 4.6,
          "title": "Add data minimization controls",
          "description": "Implement practices to limit ePHI exposure according to the Privacy Rule",
          "status": "done"
        }
      ]
    },
    {
      "id": 5,
      "title": "Company and Office Management API with HIPAA Compliance",
      "description": "Implement API endpoints for managing the hierarchical structure of companies and their offices with HIPAA-compliant data handling.",
      "status": "done",
      "dependencies": [
        3
      ],
      "priority": "medium",
      "details": "Create endpoints for company creation and management with encryption for sensitive data. Implement office management within companies with RBAC controls. Develop API for assigning managers to offices with detailed audit logging. Set up relationships between offices, chiropractors, and patients with proper access controls. Implement configuration options for company-wide vs. office-specific settings. Ensure all operations involving organizational structure are logged for HIPAA compliance. Implement data minimization practices to limit ePHI exposure. Add encryption for sensitive data both at rest and in transit. Ensure proper RBAC to prevent unauthorized access to company and office data.",
      "testStrategy": "Test the creation of multi-level hierarchies with security controls. Verify proper assignment of users to offices with audit logging. Test permission inheritance through the hierarchy with RBAC validation. Ensure office-specific settings override company defaults when configured. Validate encryption of sensitive data both in transit and at rest. Test that audit logs capture all required HIPAA information. Verify that access controls prevent unauthorized access to company and office data. Test data minimization practices to ensure ePHI exposure is limited according to the Privacy Rule."
    },
    {
      "id": 6,
      "title": "Therapy Plan Management API with HIPAA Compliance",
      "description": "Develop API endpoints for creating, editing, and managing therapy plans according to SDP specifications with HIPAA-compliant data handling.",
      "status": "done",
      "dependencies": [
        4
      ],
      "priority": "high",
      "details": "Implement the following SDP-compliant endpoints with HIPAA safeguards:\n\n1. POST /plans - Create new therapy plans with audit logging\n2. GET /plans - List plans with role-based filtering and access controls\n3. GET /plans/{id} - Retrieve detailed plan information with authorization checks\n4. PUT /plans/{id} - Update existing plans with audit trails\n5. DELETE /plans/{id} - Remove plans with secure deletion practices\n6. POST /plans/{id}/assign - Assign plans to patients with consent tracking\n\nEnsure all endpoints follow SDP request/response formats. Implement functionality for adding exercises with text, images, and videos with encryption for any ePHI. Develop API for assigning plans to patients with detailed audit logging. Create endpoints for retrieving plans assigned to a specific patient with RBAC controls. Implement versioning for therapy plans to track changes for HIPAA compliance. Ensure all data is encrypted both at rest and in transit. Implement data minimization practices to limit ePHI exposure according to the Privacy Rule.",
      "testStrategy": "Test all endpoints against SDP specifications with HIPAA compliance verification. Verify request/response formats match documentation and include proper security controls. Test creation of plans with various media types and verify encryption. Verify plan assignment to patients with audit logging. Test retrieval of plans with proper filtering and role-based access controls. Ensure plan updates don't affect historical data and create appropriate audit trails. Validate encryption of ePHI both in transit and at rest. Test that audit logs capture all required HIPAA information. Verify that access controls prevent unauthorized access to therapy plans. Test data minimization practices to ensure ePHI exposure is limited.",
      "subtasks": [
        {
          "id": "6.1",
          "title": "Define SDP-compliant request/response schemas",
          "status": "done"
        },
        {
          "id": "6.2",
          "title": "Implement POST /plans endpoint",
          "status": "done"
        },
        {
          "id": "6.3",
          "title": "Implement GET /plans with role-based filtering",
          "status": "done"
        },
        {
          "id": "6.4",
          "title": "Implement GET /plans/{id} endpoint",
          "status": "done"
        },
        {
          "id": "6.5",
          "title": "Implement PUT /plans/{id} endpoint",
          "status": "done"
        },
        {
          "id": "6.6",
          "title": "Implement DELETE /plans/{id} endpoint",
          "status": "done"
        },
        {
          "id": "6.7",
          "title": "Implement POST /plans/{id}/assign endpoint",
          "status": "done"
        },
        {
          "id": "6.8",
          "title": "Add HIPAA-compliant audit logging",
          "description": "Implement detailed audit logging for all therapy plan operations",
          "status": "done"
        },
        {
          "id": "6.9",
          "title": "Implement data encryption",
          "description": "Add encryption for all ePHI in therapy plans at rest and in transit",
          "status": "done"
        },
        {
          "id": "6.10",
          "title": "Add consent tracking",
          "description": "Implement system to track patient consent for therapy plans",
          "status": "done"
        }
      ]
    },
    {
      "id": 7,
      "title": "Media Storage Integration (AWS S3) with HIPAA Compliance",
      "description": "Implement secure storage for therapy plan media (images and videos) using AWS S3 with HIPAA-compliant encryption and access controls.",
      "status": "done",
      "dependencies": [
        6
      ],
      "priority": "medium",
      "details": "Set up AWS S3 bucket for media storage with server-side encryption and proper BAA in place. Implement secure upload endpoints for images and videos with encryption in transit. Create signed URLs for secure media access with short expiration times. Implement media deletion and management with audit logging. Handle media compression and optimization for mobile delivery. Add image_url and video_url fields to the PlanExercises table to store references to the S3 media files. Ensure API properly handles uploads and generates appropriate URLs for storage in the database. Implement detailed audit logging for all media operations. Ensure S3 bucket policies enforce encryption and restrict access. Verify AWS BAA covers S3 storage for HIPAA compliance. Implement access controls to ensure patients can only access their own media files.",
      "testStrategy": "Test upload and retrieval of various media types and sizes with encryption verification. Verify secure access control to media files with RBAC. Test signed URL generation and expiration with security controls. Confirm proper cleanup of unused media with audit trails. Validate that image_url and video_url are correctly stored in the PlanExercises table and that they properly link to the files in S3 with encryption. Test API endpoints for media upload functionality and URL generation. Verify S3 bucket encryption settings. Test that audit logs capture all required HIPAA information for media operations. Verify that access controls prevent unauthorized access to media files.",
      "subtasks": [
        {
          "id": 7.1,
          "title": "Add image_url and video_url fields to PlanExercises table",
          "status": "done",
          "description": "Modify the database schema to include image_url and video_url fields in the PlanExercises table to store references to media files in S3."
        },
        {
          "id": 7.2,
          "title": "Implement API endpoints for media uploads",
          "status": "done",
          "description": "Create API endpoints that handle media uploads to S3 and return the generated URLs for storage in the database."
        },
        {
          "id": 7.3,
          "title": "Update exercise creation/editing to support media URLs",
          "status": "done",
          "description": "Modify the exercise creation and editing functionality to support uploading and associating media files with exercises."
        },
        {
          "id": 7.4,
          "title": "Configure S3 bucket with server-side encryption",
          "description": "Set up AWS S3 bucket with server-side encryption for HIPAA compliance",
          "status": "done"
        },
        {
          "id": 7.5,
          "title": "Implement signed URLs with short expiration",
          "description": "Create system for generating signed URLs with short expiration times for secure media access",
          "status": "done"
        },
        {
          "id": 7.6,
          "title": "Add HIPAA-compliant audit logging",
          "description": "Implement detailed audit logging for all media operations",
          "status": "done"
        },
        {
          "id": 7.7,
          "title": "Verify AWS BAA for S3",
          "description": "Ensure Business Associate Agreement with AWS covers S3 storage for HIPAA compliance",
          "status": "done"
        }
      ]
    },
    {
      "id": 8,
      "title": "Patient Progress Tracking API with HIPAA Compliance",
      "description": "Implement API endpoints for tracking and reporting patient progress with therapy plans, ensuring HIPAA-compliant data handling.",
      "status": "done",
      "dependencies": [
        6
      ],
      "priority": "medium",
      "details": "Create endpoints for recording exercise completion with encryption for ePHI, specifically:\n- POST /progress: For batch updating exercise completion status from mobile app with audit logging\n- GET /progress/{patient_id}: For chiropractors to view patient progress with RBAC controls\n\nImplement progress synchronization from mobile app with encryption in transit. Develop reporting endpoints for chiropractors to view patient adherence with data minimization. Implement analytics for therapy plan effectiveness with de-identified data where possible. Create notification triggers based on patient progress with no ePHI in notification content.\n\nAll request and response formats must follow SDP (Standard Data Protocol) specifications. Implement detailed audit logging for all progress tracking operations. Ensure all data is encrypted both at rest and in transit. Implement access controls to ensure only authorized providers can access patient progress data.",
      "testStrategy": "Test progress recording with various scenarios (online/offline sync) and verify encryption. Verify accurate reporting of completion percentages with RBAC controls. Test data aggregation for analytics with privacy safeguards. Ensure proper handling of timezone differences in progress tracking. Validate all request/response formats against SDP specifications. Test authorization to ensure patient progress data is only accessible to authorized chiropractors with audit logging. Verify encryption of ePHI both in transit and at rest. Test that audit logs capture all required HIPAA information. Verify that access controls prevent unauthorized access to progress data. Test that notifications do not contain ePHI.",
      "subtasks": [
        {
          "id": "8.1",
          "title": "Define API endpoint specifications",
          "description": "Document the detailed specifications for POST /progress and GET /progress/{patient_id} endpoints including request/response formats according to SDP",
          "status": "done"
        },
        {
          "id": "8.2",
          "title": "Implement batch progress update endpoint",
          "description": "Create the POST /progress endpoint for updating exercise completion status in batches from the mobile app",
          "status": "done"
        },
        {
          "id": "8.3",
          "title": "Implement patient progress retrieval endpoint",
          "description": "Create the GET /progress/{patient_id} endpoint for chiropractors to view patient progress with proper authorization checks",
          "status": "done"
        },
        {
          "id": "8.4",
          "title": "Implement SDP validation",
          "description": "Add validation to ensure all requests and responses conform to SDP specifications",
          "status": "done"
        },
        {
          "id": "8.5",
          "title": "Add HIPAA-compliant audit logging",
          "description": "Implement detailed audit logging for all progress tracking operations",
          "status": "done"
        },
        {
          "id": "8.6",
          "title": "Implement data encryption",
          "description": "Add encryption for all progress data at rest and in transit",
          "status": "done"
        },
        {
          "id": "8.7",
          "title": "Enhance RBAC for progress data",
          "description": "Implement strict access controls to ensure only authorized providers can access patient progress",
          "status": "done"
        },
        {
          "id": "8.8",
          "title": "Add data minimization for reports",
          "description": "Implement practices to limit ePHI exposure in progress reports according to the Privacy Rule",
          "status": "done"
        }
      ]
    },
    {
      "id": 9,
      "title": "Payment Processing API with HIPAA Compliance",
      "description": "Integrate payment processing for the SaaS provider to bill individual Offices for software usage. This involves managing subscription status and payment provider details at the Office level, and integrating with a payment gateway. Your SaaS payment provider API keys will be stored in .env, not the database. All billing and payment logic should align with the canonical specification in docs/payment-plan.md.",
      "status": "pending",
      "dependencies": [
        5
      ],
      "priority": "medium",
      "details": "Integrate with a payment gateway (e.g., Stripe) for processing subscription payments at the Office level, following the specifications in docs/payment-plan.md. Store subscription status and billing information in the Office table while keeping payment provider API keys in .env files for security. Create endpoints for subscription management and payment processing with appropriate RBAC controls. Implement billing records and invoice generation with minimal ePHI inclusion. Set up webhook handlers for payment events with audit logging. Ensure all payment data transmission uses TLS 1.2+ encryption. Implement detailed audit trails for all payment transactions. Develop functionality to track subscription status, billing cycles, and payment history for each Office, adhering to the payment plan structure defined in the documentation.",
      "testStrategy": "Test subscription billing with test credentials, ensuring alignment with docs/payment-plan.md specifications. Verify proper recording of subscription status and billing information at the Office level. Test subscription creation, updates, and cancellations. Ensure proper error handling for failed payments. Validate that payment configurations are correctly loaded from environment variables. Verify audit logs are created for all payment actions. Test RBAC to ensure only authorized users can access payment information. Validate that all API communications use proper encryption. Test webhook handling for payment events from the payment gateway.",
      "subtasks": [
        {
          "id": 1,
          "title": "Revert `payment_config` from `Company` Model & Clean Alembic",
          "description": "Remove the `payment_config` JSON column from the `Company` model in `api/models/base.py`. Create a new Alembic migration to reflect this removal or ensure the previous migration that added it is cleanly reversed/removed if no other changes depend on it.",
          "details": "",
          "status": "done",
          "dependencies": [],
          "parentTaskId": 9
        },
        {
          "id": 2,
          "title": "Define and Add Subscription Fields to `Office` Model",
          "description": "Define necessary fields for office-level subscriptions (e.g., `subscription_status`, `payment_provider_customer_id`, `payment_provider_subscription_id`, `current_plan_id`, `billing_cycle_anchor_date`). Add these fields to the `Office` model in `api/models/base.py`. Ensure all fields align with the payment plan structure defined in docs/payment-plan.md.",
          "details": "",
          "status": "done",
          "dependencies": [],
          "parentTaskId": 9
        },
        {
          "id": 3,
          "title": "Generate Alembic Migration for `Office` Subscription Fields",
          "description": "After adding subscription-related fields to the `Office` model, generate a new Alembic migration script to apply these changes to the database schema.",
          "details": "\n\n<info added on 2025-05-20T03:49:09.977Z>\nThe Alembic migrations are currently paused for local development due to libSQL/driver instability. Schema changes for the Office model (from subtask 9.2) are being handled by SQLAlchemy's `create_all()` method during application startup. \n\nWhen Alembic is re-enabled, we'll need to:\n1. Run `alembic revision --autogenerate -m \"Add subscription fields to Office model\"` to generate the migration script\n2. Review the generated script to ensure it correctly captures all field additions\n3. Test the migration on a staging database before applying to production\n4. Document the migration in our schema change log\n\nThis subtask will be revisited when Alembic is re-enabled. In the meantime, ensure all schema changes are properly documented for future migration creation.\n</info added on 2025-05-20T03:49:09.977Z>\n<info added on 2025-05-20T19:56:24.570Z>\nThe migration process is now handled by our custom migration tool for libSQL (developed in Task #33) instead of Alembic. Schema changes for the Office model (from subtask 9.2) will need to be properly migrated using this new approach.\n\nWhen implementing the subscription fields migration:\n1. Create a new migration file using `libsql-migrate create \"Add subscription fields to Office model\"`\n2. Define both the up and down migration functions in the generated file\n3. Test the migration on a local database instance\n4. Apply to staging using `libsql-migrate apply --env=staging`\n5. After verification, apply to production with `libsql-migrate apply --env=production`\n6. Update the schema change log with details of the migration\n\nThis custom migration tool addresses the previous libSQL/driver instability issues while providing reliable schema versioning.\n</info added on 2025-05-20T19:56:24.570Z>",
          "status": "pending",
          "dependencies": [],
          "parentTaskId": 9
        },
        {
          "id": 4,
          "title": "HIPAA-Compliant Audit Logging for Billing Events",
          "description": "Implement detailed audit trails for all office-level subscription and billing-related operations (e.g., subscription creation, status changes, payment attempts) using libSQL/SQLite.",
          "details": "",
          "status": "done",
          "dependencies": [],
          "parentTaskId": 9
        },
        {
          "id": 5,
          "title": "Verify BAA with Chosen SaaS Payment Processor",
          "description": "Ensure a Business Associate Agreement (BAA) is in place with the payment gateway provider selected for handling the SaaS subscription billing for offices.",
          "details": "",
          "status": "pending",
          "dependencies": [],
          "parentTaskId": 9
        },
        {
          "id": 6,
          "title": "Secure Storage and Transmission of Payment Provider References",
          "description": "Ensure any stored references to payment provider entities (e.g., customer IDs for offices, subscription IDs) are handled securely within the database. All data transmission related to billing (e.g., to/from payment gateway) must use TLS 1.2+.",
          "details": "",
          "status": "pending",
          "dependencies": [],
          "parentTaskId": 9
        },
        {
          "id": 7,
          "title": "Data Minimization for SaaS Invoices to Offices",
          "description": "Implement practices to limit unnecessary data exposure in invoices generated by the SaaS for its customers (Offices), aligning with privacy principles.",
          "details": "",
          "status": "pending",
          "dependencies": [],
          "parentTaskId": 9
        },
        {
          "id": 8,
          "title": "Review and Implement Payment Plan Documentation",
          "description": "Thoroughly review docs/payment-plan.md to ensure all implementation details for billing and payment processing align with the canonical specification. Update implementation plans as needed to match the documented requirements.",
          "details": "This includes reviewing payment tiers, billing cycles, upgrade/downgrade logic, trial periods, and any other payment-related specifications in the documentation.",
          "status": "pending",
          "dependencies": [],
          "parentTaskId": 9
        },
        {
          "id": 9,
          "title": "Align Billing API and Data Models with payment-plan.md",
          "description": "Review docs/payment-plan.md and ensure all billing API endpoints, data models, and business logic are consistent with the specifications in this document. Update or add additional fields, endpoints, or logic as needed to fully implement the payment and billing structure described.",
          "details": "",
          "status": "pending",
          "dependencies": [],
          "parentTaskId": 9
        },
        {
          "id": 10,
          "title": "Design and Implement Invoice Table",
          "description": "Create a table to store monthly and one-off invoices for each office, including billing period, total, status, and references to line items, as described in docs/payment-plan.md.",
          "details": "",
          "status": "pending",
          "dependencies": [],
          "parentTaskId": 9
        },
        {
          "id": 11,
          "title": "Design and Implement Invoice Line Item Table",
          "description": "Create a table to store detailed line items for each invoice (e.g., patient activations, setup fees), as specified in docs/payment-plan.md.",
          "details": "",
          "status": "pending",
          "dependencies": [],
          "parentTaskId": 9
        },
        {
          "id": 12,
          "title": "Update Patient/User Model for Billing Status",
          "description": "Add fields to the patient/user model to track activation/deactivation dates and billing status for each billing cycle, supporting the per-patient billing logic in docs/payment-plan.md.",
          "details": "",
          "status": "pending",
          "dependencies": [],
          "parentTaskId": 9
        },
        {
          "id": 13,
          "title": "Implement Patient Activation Billing Logic",
          "description": "Ensure that activating a patient account adds a line item to the current invoice for the office. Handle reactivation and deactivation logic as described in docs/payment-plan.md.",
          "details": "",
          "status": "pending",
          "dependencies": [],
          "parentTaskId": 9
        },
        {
          "id": 14,
          "title": "Implement Monthly Invoice Generation Logic",
          "description": "At the start of each billing cycle, generate invoices for all offices, including all active patients and any reactivations. Ensure deactivated accounts are not billed in future cycles unless reactivated, per docs/payment-plan.md.",
          "details": "",
          "status": "pending",
          "dependencies": [],
          "parentTaskId": 9
        },
        {
          "id": 15,
          "title": "Implement One-Off Invoice/Charge Logic (e.g., Setup Fee)",
          "description": "Allow creation of one-off invoices/charges for offices (e.g., onboarding/setup fee) outside the regular billing cycle, as described in docs/payment-plan.md.",
          "details": "",
          "status": "pending",
          "dependencies": [],
          "parentTaskId": 9
        },
        {
          "id": 16,
          "title": "Integrate with Payment Provider for Invoicing and Payments",
          "description": "Ensure each office has a customer record in the payment provider. Generate and send invoices via the payment provider, and track payment status and update invoice records accordingly, as described in docs/payment-plan.md.",
          "details": "",
          "status": "pending",
          "dependencies": [],
          "parentTaskId": 9
        },
        {
          "id": 17,
          "title": "Implement API Endpoints for Invoice Retrieval and Payment Status",
          "description": "Create endpoints for offices to view their invoices, line items, and payment status, as described in docs/payment-plan.md.",
          "details": "",
          "status": "pending",
          "dependencies": [],
          "parentTaskId": 9
        },
        {
          "id": 18,
          "title": "Implement Audit Logging for All Billing Events",
          "description": "Log all billing-related actions (invoice creation, payment, patient activation, etc.) for compliance, as described in docs/payment-plan.md and developer-compliance-guide.md.",
          "details": "",
          "status": "pending",
          "dependencies": [],
          "parentTaskId": 9
        },
        {
          "id": 19,
          "title": "Implement Data Minimization and Security for Billing Data",
          "description": "Ensure only necessary billing data is exposed via the API and that all sensitive data is handled securely, as described in docs/payment-plan.md and developer-compliance-guide.md.",
          "details": "",
          "status": "pending",
          "dependencies": [],
          "parentTaskId": 9
        },
        {
          "id": 20,
          "title": "Write Tests for Billing Logic and API Endpoints",
          "description": "Add unit and integration tests to verify correct billing, invoice generation, and payment processing, as described in docs/payment-plan.md.",
          "details": "",
          "status": "pending",
          "dependencies": [],
          "parentTaskId": 9
        },
        {
          "id": 21,
          "title": "Document Billing API and Data Model",
          "description": "Update or create documentation for the billing API, data models, and business logic, referencing docs/payment-plan.md.",
          "details": "",
          "status": "pending",
          "dependencies": [],
          "parentTaskId": 9
        }
      ]
    },
    {
      "id": 10,
      "title": "Branding Customization API with HIPAA Compliance",
      "description": "Implement API endpoints for customizing the mobile app's appearance for each office or company while maintaining HIPAA compliance.",
      "status": "pending",
      "dependencies": [
        5
      ],
      "priority": "low",
      "details": "Create a POST /branding endpoint for uploading and managing custom branding elements including logo_url and colors JSON. Store branding information linked to Office ID in the Branding table with appropriate encryption at rest. Implement color scheme customization options. Develop API for retrieving branding information for mobile app with proper RBAC. Set up default branding fallbacks. Implement validation for uploaded assets. Ensure all branding operations are logged in the audit trail. Implement secure file handling for any uploaded assets to prevent potential PHI exposure. Use libSQL/SQLite JSON1 extension for storing and querying the colors JSON data. Adapt SQLAlchemy models to use appropriate libSQL/SQLite data types and constraints.",
      "testStrategy": "Test upload and retrieval of custom branding elements via the POST /branding endpoint. Verify proper storage of branding information linked to Office ID in the Branding table with encryption. Verify proper application of branding hierarchy (office overrides company). Test fallback to defaults when custom branding is not provided. Verify RBAC controls prevent unauthorized access to branding configurations. Validate audit logs are created for all branding changes. Test that all communications use TLS 1.2+ encryption. Verify JSON1 extension functionality with libSQL/SQLite for proper handling of colors JSON data.",
      "subtasks": [
        {
          "id": 10.1,
          "title": "Create POST /branding endpoint",
          "description": "Implement endpoint that accepts logo_url and colors JSON parameters",
          "status": "pending"
        },
        {
          "id": 10.2,
          "title": "Set up Branding database table",
          "description": "Create table structure to store branding information with foreign key relationship to Office ID using libSQL/SQLite schema",
          "status": "pending"
        },
        {
          "id": 10.3,
          "title": "Implement branding retrieval logic",
          "description": "Create endpoint to fetch branding information for a specific office with appropriate fallbacks",
          "status": "pending"
        },
        {
          "id": 10.4,
          "title": "Add RBAC to branding endpoints",
          "description": "Implement role-based access controls for all branding operations",
          "status": "pending"
        },
        {
          "id": 10.5,
          "title": "Implement audit logging for branding changes",
          "description": "Add detailed audit trails for all branding-related operations using libSQL/SQLite",
          "status": "pending"
        },
        {
          "id": 10.6,
          "title": "Implement secure file handling",
          "description": "Add secure handling for uploaded assets to prevent PHI exposure",
          "status": "pending"
        },
        {
          "id": 10.7,
          "title": "Add encryption for branding data",
          "description": "Implement encryption for branding information at rest using methods compatible with libSQL/SQLite",
          "status": "pending"
        }
      ]
    },
    {
      "id": 11,
      "title": "Notification Configuration API with HIPAA Compliance",
      "description": "Implement API endpoints for configuring patient notification schedules with HIPAA-compliant data handling.",
      "status": "pending",
      "dependencies": [
        6
      ],
      "priority": "medium",
      "details": "Create endpoints for setting up notification schedules for therapy plans with RBAC controls. Implement time-based and event-based notification triggers. Develop configuration options for notification frequency and timing. Create endpoints for retrieving notification settings for the mobile app. Ensure notification content does not contain ePHI to comply with the Privacy Rule. Implement audit logging for all notification configuration changes. Use encryption for all notification data at rest and in transit. Ensure notification delivery mechanisms comply with HIPAA requirements. Adapt database models to use libSQL/SQLite data types and constraints. Use JSON1 extension for storing complex notification configuration data.",
      "testStrategy": "Test creation of various notification schedules. Verify proper time calculations for different timezones. Test retrieval of notification settings by the mobile app. Validate that notification content does not expose ePHI. Verify RBAC controls prevent unauthorized access to notification configurations. Test audit logging for all notification operations. Ensure all API communications use proper encryption. Validate that notification delivery complies with HIPAA requirements. Test compatibility with libSQL/SQLite, particularly for JSON data storage and retrieval.",
      "subtasks": [
        {
          "id": 11.1,
          "title": "Create notification schedule endpoints",
          "description": "Implement endpoints for creating and managing notification schedules using libSQL/SQLite for data storage",
          "status": "pending"
        },
        {
          "id": 11.2,
          "title": "Implement HIPAA-compliant notification content",
          "description": "Ensure notification templates do not contain ePHI",
          "status": "pending"
        },
        {
          "id": 11.3,
          "title": "Add RBAC for notification configuration",
          "description": "Implement role-based access controls for notification management",
          "status": "pending"
        },
        {
          "id": 11.4,
          "title": "Implement audit logging",
          "description": "Add detailed audit trails for all notification configuration operations using libSQL/SQLite",
          "status": "pending"
        },
        {
          "id": 11.5,
          "title": "Add data encryption",
          "description": "Implement encryption for notification data at rest and in transit, adapting methods for libSQL/SQLite",
          "status": "pending"
        },
        {
          "id": 11.6,
          "title": "Verify HIPAA compliance for delivery mechanisms",
          "description": "Ensure notification delivery methods comply with HIPAA requirements",
          "status": "pending"
        }
      ]
    },
    {
      "id": 12,
      "title": "React Web Application Setup with HIPAA Compliance",
      "description": "Set up the React web application for chiropractors with routing and state management, focusing on login, account management, and therapy plan creation while ensuring HIPAA compliance.",
      "status": "in-progress",
      "dependencies": [
        3
      ],
      "priority": "high",
      "details": "Initialize React application with proper project structure. Set up routing with React Router including RBAC for protected routes. Implement state management with Redux or Context API with secure handling of ePHI. Create authentication flows with multi-factor authentication options and automatic session timeouts. Implement protected routes for login and account management. Develop responsive design framework. Set up API client for backend communication with TLS 1.2+ encryption. Implement secure local storage handling to prevent ePHI caching. Develop interfaces for therapy plan creation with audit logging. Consider optional Dockerization using Node.js and Nginx for deployment if desired, with proper security configurations. Implement client-side data encryption for any sensitive information. Update API client to handle any specific requirements for communicating with the libSQL/SQLite backend.",
      "testStrategy": "Test application initialization and routing. Verify protected routes redirect unauthenticated users. Test RBAC implementation for different user roles. Validate session timeout functionality. Test responsive layouts on different screen sizes. Ensure API client correctly handles authentication tokens and uses proper encryption. Validate therapy plan creation workflow with audit logging. Test secure storage handling to prevent ePHI exposure. If Dockerized, test container deployment with security configurations. Verify API client correctly handles any specific requirements for the libSQL/SQLite backend.",
      "subtasks": [
        {
          "id": "12.1",
          "title": "Set up basic React application structure",
          "status": "pending"
        },
        {
          "id": "12.2",
          "title": "Implement authentication and login interface",
          "status": "pending"
        },
        {
          "id": "12.3",
          "title": "Create account management screens",
          "status": "pending"
        },
        {
          "id": "12.4",
          "title": "Develop therapy plan creation interface",
          "status": "pending"
        },
        {
          "id": "12.5",
          "title": "Set up API client for backend communication",
          "description": "Configure API client to handle communication with the libSQL/SQLite backend",
          "status": "pending"
        },
        {
          "id": "12.6",
          "title": "Create Dockerfile and Nginx configuration (optional)",
          "status": "pending"
        },
        {
          "id": "12.7",
          "title": "Implement HIPAA-compliant session management",
          "description": "Add automatic session timeouts and secure session handling",
          "status": "pending"
        },
        {
          "id": "12.8",
          "title": "Set up client-side RBAC implementation",
          "description": "Implement role-based access controls for UI components and routes",
          "status": "pending"
        },
        {
          "id": "12.9",
          "title": "Implement secure local storage handling",
          "description": "Ensure no ePHI is cached in browser storage",
          "status": "pending"
        },
        {
          "id": "12.10",
          "title": "Add client-side audit logging",
          "description": "Implement detailed logging of user actions for HIPAA compliance",
          "status": "pending"
        },
        {
          "id": "12.11",
          "title": "Implement multi-factor authentication",
          "description": "Add MFA options for enhanced security of ePHI access",
          "status": "pending"
        },
        {
          "id": "12.12",
          "title": "Add client-side data encryption",
          "description": "Implement encryption for any sensitive data handled in the browser",
          "status": "pending"
        }
      ]
    },
    {
      "id": 13,
      "title": "Web App User Management Interface with HIPAA Compliance",
      "description": "Implement user management interfaces for the web application with HIPAA-compliant data handling and access controls.",
      "status": "pending",
      "dependencies": [
        12,
        4
      ],
      "priority": "high",
      "details": "Create interfaces for user listing, creation, editing, and deletion with RBAC controls. Implement role assignment functionality with principle of least privilege. Develop patient management screens for chiropractors with minimal ePHI exposure. Create join code generation and management UI. Implement search and filtering for user lists with audit logging for all searches involving patient data. Ensure all user management operations are logged in detail. Implement secure data handling practices to limit ePHI exposure according to the Privacy Rule. Add consent management features for patient data handling. Update API interactions to accommodate any changes in data format or response structure due to the libSQL/SQLite migration.",
      "testStrategy": "Test user CRUD operations through the UI with different user roles. Verify proper display of role-specific information based on RBAC. Test join code generation and display. Ensure proper error handling and user feedback. Validate audit logging for all user management operations. Test that searches involving patient data are properly logged. Verify that ePHI exposure is limited according to the Privacy Rule. Test consent management features. Verify compatibility with the libSQL/SQLite backend, particularly for search and filtering operations.",
      "subtasks": [
        {
          "id": 13.1,
          "title": "Create user listing interface with RBAC",
          "description": "Implement UI for viewing users with role-based filtering and access controls",
          "status": "pending"
        },
        {
          "id": 13.2,
          "title": "Develop user creation/editing forms",
          "description": "Create forms for adding and modifying users with proper validation",
          "status": "pending"
        },
        {
          "id": 13.3,
          "title": "Implement join code generation UI",
          "description": "Add interface for generating and managing patient join codes",
          "status": "pending"
        },
        {
          "id": 13.4,
          "title": "Add search and filtering with audit logging",
          "description": "Implement search functionality with detailed logging for HIPAA compliance, adapting to libSQL/SQLite search capabilities",
          "status": "pending"
        },
        {
          "id": 13.5,
          "title": "Create consent management interface",
          "description": "Develop UI for tracking and managing patient consent for data handling",
          "status": "pending"
        },
        {
          "id": 13.6,
          "title": "Implement data minimization in UI",
          "description": "Ensure interfaces limit display of ePHI according to the Privacy Rule",
          "status": "pending"
        }
      ]
    },
    {
      "id": 14,
      "title": "Web App Therapy Plan Creation Interface with HIPAA Compliance",
      "description": "Implement interfaces for creating and managing therapy plans with HIPAA-compliant data handling.",
      "status": "pending",
      "dependencies": [
        12,
        6,
        7
      ],
      "priority": "high",
      "details": "Create therapy plan editor with sections for details, exercises, and scheduling. Implement media upload functionality for images and videos with secure handling and encryption at rest. Develop exercise sequencing and organization tools. Create plan assignment interface for linking plans to patients with audit logging. Implement plan templates and duplication features. Ensure all therapy plan operations are logged in detail. Implement RBAC to control access to patient therapy plans. Add consent tracking for therapy plans. Ensure secure handling of any ePHI included in therapy plans. Adapt data storage and retrieval to work with libSQL/SQLite, particularly for complex data structures and media references.",
      "testStrategy": "Test creation of plans with various media types. Verify proper saving and retrieval of plan data with encryption. Test media uploads and previews with secure handling. Ensure proper validation of required fields. Validate audit logging for all therapy plan operations. Test RBAC controls for different user roles. Verify that consent is properly tracked and enforced. Test that all communications use TLS 1.2+ encryption. Verify compatibility with libSQL/SQLite for complex data structures and relationships.",
      "subtasks": [
        {
          "id": 14.1,
          "title": "Create therapy plan editor UI",
          "description": "Implement interface for creating and editing therapy plans with all required sections",
          "status": "pending"
        },
        {
          "id": 14.2,
          "title": "Implement secure media upload",
          "description": "Add functionality for uploading images and videos with encryption and secure handling",
          "status": "pending"
        },
        {
          "id": 14.3,
          "title": "Develop plan assignment interface",
          "description": "Create UI for assigning plans to patients with proper consent tracking",
          "status": "pending"
        },
        {
          "id": 14.4,
          "title": "Add template functionality",
          "description": "Implement ability to create and use plan templates",
          "status": "pending"
        },
        {
          "id": 14.5,
          "title": "Implement RBAC for therapy plans",
          "description": "Add role-based access controls to limit plan access to authorized users",
          "status": "pending"
        },
        {
          "id": 14.6,
          "title": "Add audit logging",
          "description": "Implement detailed logging of all therapy plan operations for HIPAA compliance using libSQL/SQLite",
          "status": "pending"
        },
        {
          "id": 14.7,
          "title": "Create consent tracking UI",
          "description": "Add interface for tracking patient consent for therapy plans",
          "status": "pending"
        }
      ]
    },
    {
      "id": 15,
      "title": "Web App Analytics and Reporting Dashboard with HIPAA Compliance",
      "description": "Implement analytics and reporting interfaces for tracking patient progress with HIPAA-compliant data handling.",
      "status": "pending",
      "dependencies": [
        12,
        8
      ],
      "priority": "medium",
      "details": "Create dashboard for viewing patient adherence metrics with RBAC controls. Implement charts and visualizations for progress data with de-identification where appropriate. Develop filtering and date range selection tools with audit logging for all data access. Create patient-specific progress reports with minimal ePHI inclusion. Implement export functionality for reports with encryption and access controls. Ensure all reporting operations are logged in detail. Implement data minimization practices to limit ePHI exposure. Add consent verification before generating reports containing patient data. Adapt analytics queries to use libSQL/SQLite syntax and optimize for its performance characteristics. Use JSON1 extension for complex data aggregation where appropriate.",
      "testStrategy": "Test dashboard with various data scenarios. Verify accurate calculation and display of metrics. Test filtering and date range functionality with audit logging. Ensure exports contain correct and complete data with proper encryption. Validate RBAC controls for different user roles. Test that all report generation and viewing is properly logged. Verify that ePHI exposure is limited according to the Privacy Rule. Test consent verification features. Verify performance of analytics queries with libSQL/SQLite, especially for large datasets.",
      "subtasks": [
        {
          "id": 15.1,
          "title": "Create analytics dashboard UI",
          "description": "Implement main dashboard interface with adherence metrics and visualizations",
          "status": "pending"
        },
        {
          "id": 15.2,
          "title": "Develop filtering and date range tools",
          "description": "Add controls for filtering data with audit logging, adapting to libSQL/SQLite query capabilities",
          "status": "pending"
        },
        {
          "id": 15.3,
          "title": "Implement patient progress reports",
          "description": "Create detailed reports with minimal ePHI exposure",
          "status": "pending"
        },
        {
          "id": 15.4,
          "title": "Add secure export functionality",
          "description": "Implement encrypted exports with access controls",
          "status": "pending"
        },
        {
          "id": 15.5,
          "title": "Implement RBAC for analytics",
          "description": "Add role-based access controls for dashboard and reports",
          "status": "pending"
        },
        {
          "id": 15.6,
          "title": "Add audit logging",
          "description": "Implement detailed logging of all reporting operations for HIPAA compliance using libSQL/SQLite",
          "status": "pending"
        },
        {
          "id": 15.7,
          "title": "Create consent verification system",
          "description": "Add checks to verify patient consent before generating reports",
          "status": "pending"
        },
        {
          "id": 15.8,
          "title": "Implement data de-identification",
          "description": "Add functionality to de-identify data for certain reporting scenarios",
          "status": "pending"
        }
      ]
    },
    {
      "id": 16,
      "title": "Web App Payment and Billing Interface with HIPAA Compliance",
      "description": "Implement payment management and billing interfaces for the web application with HIPAA-compliant data handling.",
      "status": "pending",
      "dependencies": [
        12,
        9
      ],
      "priority": "medium",
      "details": "Create payment configuration screens for company and office settings with RBAC controls. Implement subscription management interface. Develop invoice viewing and management tools with minimal ePHI inclusion. Create payment history and reporting screens with audit logging. Implement payment method management UI with secure handling of payment information. Ensure all payment operations are logged in detail. Implement secure data handling practices to limit ePHI exposure in billing documents. Verify BAA is in place with payment processor. Ensure invoices and billing documents comply with HIPAA requirements. Adapt payment data storage and retrieval to work with libSQL/SQLite, using JSON1 extension for complex payment configuration data.",
      "testStrategy": "Test payment configuration options with different user roles. Verify proper display of billing information with minimal ePHI. Test subscription management workflows with audit logging. Ensure proper handling of payment errors and user feedback. Validate RBAC controls for different user roles. Test that all payment operations are properly logged. Verify that payment information is securely handled and encrypted. Test that billing documents comply with HIPAA requirements. Verify compatibility with libSQL/SQLite for payment data storage and retrieval.",
      "subtasks": [
        {
          "id": 16.1,
          "title": "Create payment configuration UI",
          "description": "Implement screens for managing payment settings at company and office levels",
          "status": "pending"
        },
        {
          "id": 16.2,
          "title": "Develop subscription management interface",
          "description": "Add UI for creating and managing subscriptions",
          "status": "pending"
        },
        {
          "id": 16.3,
          "title": "Implement invoice management",
          "description": "Create screens for viewing and managing invoices with minimal ePHI",
          "status": "pending"
        },
        {
          "id": 16.4,
          "title": "Add payment history reporting",
          "description": "Implement reporting screens for payment history with audit logging, adapting queries for libSQL/SQLite",
          "status": "pending"
        },
        {
          "id": 16.5,
          "title": "Create payment method UI",
          "description": "Add interface for securely managing payment methods",
          "status": "pending"
        },
        {
          "id": 16.6,
          "title": "Implement RBAC for payment features",
          "description": "Add role-based access controls for all payment functionality",
          "status": "pending"
        },
        {
          "id": 16.7,
          "title": "Add audit logging",
          "description": "Implement detailed logging of all payment operations for HIPAA compliance using libSQL/SQLite",
          "status": "pending"
        },
        {
          "id": 16.8,
          "title": "Ensure HIPAA-compliant billing documents",
          "description": "Verify that invoices and other billing documents limit ePHI exposure",
          "status": "pending"
        }
      ]
    },
    {
      "id": 17,
      "title": "React Native Mobile App Setup with HIPAA Compliance",
      "description": "Set up the React Native mobile application for patients with navigation, state management, and offline capabilities for SDP Phase 3, ensuring HIPAA compliance.",
      "status": "pending",
      "dependencies": [
        3
      ],
      "priority": "high",
      "details": "Initialize React Native application with proper project structure. Set up navigation with React Navigation including RBAC for protected screens. Implement state management with Redux or Context API with secure handling of ePHI. Implement offline data storage using SQLite for caching plans and progress data with encryption at rest. Create authentication flows with biometric options and automatic session timeouts. Set up API client with offline capabilities and TLS 1.2+ encryption. Implement plan viewing screens for patients to access their treatment plans. Implement local notification scheduling for reminders with no ePHI in notification content. Ensure secure local storage with encryption for any ePHI. Implement detailed audit logging for all data access operations. Configure SQLite to match the schema structure used by the backend libSQL database for better compatibility and synchronization.",
      "testStrategy": "Test application initialization on both iOS and Android. Verify navigation between screens with RBAC controls. Test offline data persistence using SQLite with encryption. Verify login functionality, biometric authentication, and session timeout features. Test plan viewing functionality with both online and offline data. Ensure local notifications work correctly on both platforms without exposing ePHI. Validate secure storage implementation with encryption. Test audit logging for all data access operations. Verify that the app handles security appropriately in both online and offline modes. Test compatibility between mobile SQLite schema and backend libSQL schema during synchronization.",
      "subtasks": [
        {
          "id": "17.1",
          "title": "Set up React Native project structure",
          "status": "pending"
        },
        {
          "id": "17.2",
          "title": "Implement login screen and authentication flow",
          "status": "pending"
        },
        {
          "id": "17.3",
          "title": "Set up SQLite for offline data caching",
          "description": "Configure SQLite database with schema compatible with backend libSQL structure",
          "status": "pending"
        },
        {
          "id": "17.4",
          "title": "Create plan viewing screens for patients",
          "status": "pending"
        },
        {
          "id": "17.5",
          "title": "Implement offline synchronization for plan data",
          "description": "Create sync mechanism compatible with libSQL/SQLite backend",
          "status": "pending"
        },
        {
          "id": "17.6",
          "title": "Set up local notifications for plan reminders",
          "status": "pending"
        },
        {
          "id": "17.7",
          "title": "Implement encrypted local storage",
          "description": "Add encryption for all locally stored ePHI using secure encryption libraries",
          "status": "pending"
        },
        {
          "id": "17.8",
          "title": "Add biometric authentication option",
          "description": "Implement fingerprint/face recognition for app access on supported devices",
          "status": "pending"
        },
        {
          "id": "17.9",
          "title": "Implement session timeout functionality",
          "description": "Add automatic logout after period of inactivity to protect ePHI",
          "status": "pending"
        },
        {
          "id": "17.10",
          "title": "Set up mobile audit logging",
          "description": "Implement detailed logging of all data access operations for HIPAA compliance",
          "status": "pending"
        }
      ]
    },
    {
      "id": 18,
      "title": "Mobile App Authentication and Onboarding with HIPAA Compliance",
      "description": "Implement patient authentication, registration, and chiropractor association with HIPAA-compliant security measures.",
      "status": "pending",
      "dependencies": [
        17,
        4
      ],
      "priority": "high",
      "details": "Create login and registration screens with secure data handling. Implement join code entry and validation. Develop onboarding flow for new patients including consent collection for data handling. Create account management screens with minimal ePHI display. Implement secure token storage and refresh mechanisms with encryption. For SDP Association, patients will associate with their chiropractor using a unique join code or link provided by the chiropractor. This association must be validated through the POST /auth/associate endpoint. Implement biometric authentication options where available. Add automatic session timeouts after periods of inactivity. Ensure all authentication operations are logged in detail. Store authentication data locally using SQLite with encryption for offline access.",
      "testStrategy": "Test registration and login flows with security controls. Verify join code validation and association with chiropractors using the POST /auth/associate endpoint. Test both join code and link-based association methods. Test token refresh and session management including timeouts. Test biometric authentication on supported devices. Ensure proper error handling and user feedback during the association process. Validate audit logging for all authentication operations. Verify that consent collection is properly implemented and recorded. Test that all communications use TLS 1.2+ encryption. Test offline authentication using locally stored SQLite data.",
      "subtasks": [
        {
          "id": 18.1,
          "title": "Create login and registration screens",
          "description": "Implement secure authentication UI with proper validation",
          "status": "pending"
        },
        {
          "id": 18.2,
          "title": "Implement join code validation",
          "description": "Add functionality to validate join codes through the POST /auth/associate endpoint",
          "status": "pending"
        },
        {
          "id": 18.3,
          "title": "Develop patient onboarding flow",
          "description": "Create step-by-step onboarding process including consent collection",
          "status": "pending"
        },
        {
          "id": 18.4,
          "title": "Implement secure token storage",
          "description": "Add encrypted storage for authentication tokens using SQLite",
          "status": "pending"
        },
        {
          "id": 18.5,
          "title": "Add biometric authentication",
          "description": "Implement fingerprint/face recognition for app access on supported devices",
          "status": "pending"
        },
        {
          "id": 18.6,
          "title": "Create session timeout functionality",
          "description": "Add automatic logout after period of inactivity",
          "status": "pending"
        },
        {
          "id": 18.7,
          "title": "Implement audit logging",
          "description": "Add detailed logging of all authentication operations for HIPAA compliance",
          "status": "pending"
        },
        {
          "id": 18.8,
          "title": "Add consent management",
          "description": "Implement system to track and store patient consent for data handling",
          "status": "pending"
        }
      ]
    },
    {
      "id": 19,
      "title": "Mobile App Therapy Plan Viewer with HIPAA Compliance",
      "description": "Implement the therapy plan viewer with offline capabilities using SQLite for local storage, ensuring HIPAA-compliant data handling.",
      "status": "pending",
      "dependencies": [
        17,
        6,
        7
      ],
      "priority": "high",
      "details": "Create therapy plan listing screen with minimal ePHI display. Implement detailed plan view with exercise instructions. Develop media viewing capabilities for images and videos. Create progress tracking with checkboxes for completed exercises. Implement offline functionality using SQLite database for structured data storage with encryption at rest. Set up API synchronization to retrieve plans and store them locally. Implement offline media caching system for videos and images to ensure they're available without network connection. Ensure all data access is logged for audit purposes. Implement secure data wiping functionality for when consent is withdrawn. Add access controls to ensure patients can only view their own plans. Design SQLite schema to be compatible with the backend libSQL database structure for seamless synchronization.",
      "testStrategy": "Test plan viewing with various media types. Verify offline functionality by disabling network access after initial sync. Test database operations for storing and retrieving therapy plans with encryption. Verify media caching works correctly for different file sizes and types. Test progress tracking and synchronization when returning online. Ensure proper handling of large media files and storage constraints. Validate audit logging for all data access operations. Test secure data wiping functionality. Verify that access controls prevent unauthorized access to plans. Test that all stored data is properly encrypted at rest. Verify compatibility between mobile SQLite and backend libSQL during synchronization.",
      "subtasks": [
        {
          "id": "19.1",
          "title": "Implement SQLite database schema for therapy plans",
          "status": "pending",
          "description": "Design and implement SQLite database schema to store therapy plans, exercises, and progress tracking information locally, ensuring compatibility with backend libSQL structure."
        },
        {
          "id": "19.2",
          "title": "Create API synchronization service",
          "status": "pending",
          "description": "Develop service to fetch therapy plans from API and store them in local SQLite database. Include logic for determining when to update local data and handling libSQL/SQLite specific data formats."
        },
        {
          "id": "19.3",
          "title": "Implement media download and caching system",
          "status": "pending",
          "description": "Create system to download and cache media files (images/videos) when online for offline viewing. Include storage management to prevent excessive space usage."
        },
        {
          "id": "19.4",
          "title": "Update UI components to work with offline data",
          "status": "pending",
          "description": "Modify therapy plan listing and detail views to retrieve data from local SQLite database instead of directly from API."
        },
        {
          "id": "19.5",
          "title": "Implement database encryption",
          "status": "pending",
          "description": "Add encryption for SQLite database to protect ePHI at rest"
        },
        {
          "id": "19.6",
          "title": "Add audit logging for data access",
          "status": "pending",
          "description": "Implement detailed logging of all therapy plan access and viewing operations"
        },
        {
          "id": "19.7",
          "title": "Create secure data wiping functionality",
          "status": "pending",
          "description": "Implement feature to securely delete all patient data when requested or when consent is withdrawn"
        },
        {
          "id": "19.8",
          "title": "Implement access controls",
          "status": "pending",
          "description": "Add controls to ensure patients can only access their own plans"
        },
        {
          "id": "19.9",
          "title": "Add data minimization for plan display",
          "status": "pending",
          "description": "Implement practices to limit ePHI exposure in plan listings and details"
        }
      ]
    },
    {
      "id": 20,
      "title": "Mobile App Notification and Progress Sync with HIPAA Compliance",
      "description": "Implement local notifications and progress synchronization with HIPAA-compliant data handling.",
      "status": "pending",
      "dependencies": [
        19,
        8,
        11
      ],
      "priority": "medium",
      "details": "Create background synchronization service for progress data using SQLite for local storage with encryption and POST /progress endpoint for server sync. Implement local notification scheduling using `react-native-push-notification` library based on therapy plan timing with no ePHI in notification content. Develop conflict resolution for offline progress updates. Create notification management settings. Implement background fetch for updated therapy plans. Add interactive checklist UI for progress tracking. Ensure all data synchronization operations are logged in detail. Implement secure handling of progress data with encryption at rest and in transit. Add consent verification before syncing data to server. Design SQLite schema to match the backend libSQL structure for efficient synchronization.",
      "testStrategy": "Test notification triggering at scheduled times without exposing ePHI. Verify progress synchronization after offline usage with encryption. Test conflict resolution with simultaneous updates. Ensure battery-efficient background operations. Validate interactive checklist UI functionality and state persistence. Test audit logging for all data synchronization operations. Verify that all stored data is properly encrypted at rest. Test that all communications use TLS 1.2+ encryption. Validate consent verification before data synchronization. Test compatibility between mobile SQLite and backend libSQL during synchronization.",
      "subtasks": [
        {
          "id": "20.1",
          "title": "Implement local storage with SQLite",
          "description": "Set up SQLite database schema for storing progress data locally, compatible with backend libSQL structure",
          "status": "pending"
        },
        {
          "id": "20.2",
          "title": "Integrate react-native-push-notification",
          "description": "Add the library and configure it for local notifications based on therapy plan schedule",
          "status": "pending"
        },
        {
          "id": "20.3",
          "title": "Create sync service",
          "description": "Implement background service to sync local progress data with server via POST /progress endpoint when online",
          "status": "pending"
        },
        {
          "id": "20.4",
          "title": "Develop interactive checklist UI",
          "description": "Create user interface for progress tracking with interactive checklist components",
          "status": "pending"
        },
        {
          "id": "20.5",
          "title": "Implement conflict resolution",
          "description": "Add logic to handle conflicts between local and server data during synchronization",
          "status": "pending"
        },
        {
          "id": "20.6",
          "title": "Add encryption to local storage",
          "description": "Implement encryption for all locally stored progress data",
          "status": "pending"
        },
        {
          "id": "20.7",
          "title": "Create HIPAA-compliant notifications",
          "description": "Ensure notifications do not contain any ePHI in their content",
          "status": "pending"
        },
        {
          "id": "20.8",
          "title": "Implement audit logging",
          "description": "Add detailed logging of all progress tracking and synchronization operations",
          "status": "pending"
        },
        {
          "id": "20.9",
          "title": "Add consent verification",
          "description": "Implement check for valid consent before syncing data to server",
          "status": "pending"
        }
      ]
    },
    {
      "id": 21,
      "title": "Implement HIPAA Compliance Foundations in API Core",
      "description": "Integrate foundational HIPAA compliance measures into the API core structure to ensure secure handling of protected health information (PHI) according to regulatory requirements.",
      "details": "This task requires implementing several key HIPAA compliance components at the API core level:\n\n1. **Security Configuration Review**:\n   - Audit existing API configurations and modify defaults to enforce secure settings\n   - Implement automatic session timeouts after periods of inactivity\n   - Configure proper TLS/SSL settings with modern cipher suites (to be enforced in staging/production)\n   - Disable any insecure defaults that may exist in the framework\n\n2. **Audit Logging Infrastructure**:\n   - Implement comprehensive audit logging for all PHI access, modifications, and transmissions\n   - Log user actions with timestamps, user IDs, actions performed, and affected resources\n   - Ensure logs cannot be modified or deleted by regular users\n   - Create log rotation and retention policies compliant with HIPAA's 6-year retention requirement\n\n3. **Encryption Implementation**:\n   - Apply encryption at rest for all PHI stored in databases or file systems\n   - Configure the application to support TLS 1.2+ for encryption in transit\n   - Support HTTP for local development while ensuring the application is ready for HTTPS in staging/production\n   - Create key management procedures for encryption keys\n   - Document encryption standards used for compliance documentation\n\n4. **Data Handling Controls**:\n   - Implement input validation and sanitization for all API endpoints\n   - Create mechanisms to detect and prevent PHI from appearing in error logs\n   - Establish proper content-type headers and response structures\n   - Implement minimum necessary principle by filtering response data based on user roles\n   - Ensure all data handling code assumes secure transmission in production environments\n\n5. **Documentation Updates**:\n   - Update technical documentation to reflect HIPAA compliance measures\n   - Create developer guidelines for maintaining compliance when modifying the API\n   - Document the environment-specific security configurations (local vs. staging/production)\n\nRefer to docs/healthcare-compliance.md for complete requirements and implementation standards. This implementation should be done at the core/foundation level to ensure all API components inherit these security controls.",
      "testStrategy": "Testing should verify all HIPAA compliance measures are correctly implemented:\n\n1. **Security Configuration Tests**:\n   - Verify the application is properly configured to support TLS when deployed\n   - Confirm the application works correctly over HTTP in local development\n   - Test session timeout functionality by monitoring inactive sessions\n   - Attempt to use deprecated/insecure methods to confirm they're disabled\n   - Document TLS verification tests to be performed in staging/production environments\n\n2. **Audit Logging Tests**:\n   - Perform various API operations and verify appropriate audit logs are generated\n   - Attempt to modify logs directly to confirm immutability\n   - Verify log format contains all required HIPAA elements (who, what, when, where)\n   - Test log rotation and confirm older logs remain accessible\n\n3. **Encryption Tests**:\n   - Use database inspection tools to verify data is encrypted at rest\n   - Verify the application is configured to support TLS 1.2+ for production use\n   - Test key rotation procedures to ensure they work without data loss\n   - Defer actual TLS connection testing (using tools like SSL Labs or testssl.sh) to deployed environments\n\n4. **Data Handling Tests**:\n   - Submit malformed/malicious inputs to verify proper validation\n   - Trigger errors and verify PHI is not exposed in error messages\n   - Test with different user roles to confirm minimum necessary principle\n   - Verify all PHI transmissions are properly structured for secure handling\n   - Confirm the application correctly handles both HTTP (dev) and HTTPS (prod) contexts\n\n5. **Compliance Verification**:\n   - Create a test checklist derived from docs/healthcare-compliance.md\n   - Perform a mock HIPAA audit against the implementation\n   - Document all test results for compliance evidence\n   - Create separate verification procedures for local development vs. production environments\n\nAll tests should be automated where possible and included in the CI/CD pipeline to ensure ongoing compliance. Environment-specific tests (like TLS verification) should be clearly marked for execution only in the appropriate environments.",
      "status": "done",
      "dependencies": [
        3
      ],
      "priority": "high",
      "subtasks": [
        {
          "id": 1,
          "title": "Implement Security Configuration Framework",
          "description": "Create a security configuration framework that enforces HIPAA-compliant settings across different environments (development, staging, production).",
          "dependencies": [],
          "details": "Implementation details:\n1. Create a `SecurityConfigService` class to manage security configurations\n2. Implement environment-specific configuration profiles (dev, staging, prod)\n3. Configure session timeout settings (30 minutes for production, configurable for dev)\n4. Set up TLS/SSL configuration with modern cipher suites\n5. Create middleware to enforce secure headers (Content-Security-Policy, X-XSS-Protection, etc.)\n6. Disable insecure defaults in the framework\n7. Implement configuration validation to ensure security settings meet HIPAA requirements\n\nTesting approach:\n- Unit test each configuration setting\n- Create integration tests that verify security headers are properly applied\n- Test environment switching to ensure production settings cannot be bypassed\n- Validate session timeout functionality works as expected",
          "status": "done",
          "parentTaskId": 21
        },
        {
          "id": 2,
          "title": "Build Comprehensive Audit Logging System",
          "description": "Develop a robust audit logging system that captures all PHI access, modifications, and transmissions with appropriate metadata.",
          "dependencies": [
            1
          ],
          "details": "Implementation details:\n1. Create an `AuditLogger` service that integrates with the security framework\n2. Implement logging middleware to capture API requests and responses\n3. Log critical user events: authentication, PHI access, modifications, and transmissions\n4. Include metadata with each log: timestamp, user ID, IP address, action performed, resources affected\n5. Implement tamper-evident logging (e.g., using sequential IDs or checksums)\n6. Create log rotation and archiving system with 6-year retention capability\n7. Implement log access controls to prevent unauthorized modification\n8. Add configuration for log storage location (file system vs. database)\n\nTesting approach:\n- Unit test logging functions with mock data\n- Create integration tests that verify all required metadata is captured\n- Test log rotation and retention policies\n- Verify logs cannot be modified by regular users\n- Performance test logging system under load",
          "status": "done",
          "parentTaskId": 21
        },
        {
          "id": 3,
          "title": "Implement PHI Encryption Framework",
          "description": "Create a comprehensive encryption framework for protecting PHI both at rest and in transit.",
          "dependencies": [
            1
          ],
          "details": "Implementation details:\n1. Develop an `EncryptionService` that provides standardized encryption/decryption methods\n2. Implement database-level encryption for PHI fields using industry-standard algorithms (AES-256)\n3. Create key management utilities for secure key generation, storage, and rotation\n4. Configure the application to enforce TLS 1.2+ for all API communications\n5. Implement environment-aware encryption (relaxed for development, strict for production)\n6. Create utilities to verify encryption status of PHI data\n7. Document all encryption standards and methods used\n\nTesting approach:\n- Unit test encryption/decryption functions\n- Create integration tests that verify PHI is properly encrypted in the database\n- Test key rotation procedures\n- Verify TLS configuration works correctly in different environments\n- Benchmark encryption/decryption performance",
          "status": "done",
          "parentTaskId": 21
        },
        {
          "id": 4,
          "title": "Develop Secure Data Handling Controls",
          "description": "Implement controls to ensure PHI is properly validated, sanitized, and filtered according to the minimum necessary principle.",
          "dependencies": [
            1,
            2,
            3
          ],
          "details": "Implementation details:\n1. Create a `DataSanitizationService` to handle input validation and sanitization\n2. Implement middleware to detect and redact PHI in error logs and responses\n3. Develop a role-based data filtering system to enforce minimum necessary principle\n4. Create request validators for all API endpoints that handle PHI\n5. Implement proper content-type headers and response structures\n6. Add PHI detection patterns to identify potential data leakage\n7. Create utilities to mask/redact PHI in logs when necessary\n\nTesting approach:\n- Unit test all sanitization and validation functions\n- Create integration tests with various user roles to verify proper data filtering\n- Test error handling to ensure PHI is not leaked in error responses\n- Verify content-type headers are properly set\n- Test with malformed input to ensure robust handling",
          "status": "done",
          "parentTaskId": 21
        },
        {
          "id": 5,
          "title": "Create HIPAA Compliance Documentation and Developer Guidelines",
          "description": "Develop comprehensive documentation for the HIPAA compliance measures implemented and create guidelines for developers to maintain compliance.",
          "dependencies": [
            1,
            2,
            3,
            4
          ],
          "details": "Implementation details:\n1. Update technical documentation to reflect all implemented HIPAA compliance measures\n2. Create developer guidelines for maintaining compliance when modifying the API\n3. Document environment-specific security configurations\n4. Create a compliance checklist for code reviews\n5. Develop training materials for new developers\n6. Document the encryption standards and key management procedures\n7. Create API usage examples that demonstrate proper handling of PHI\n8. Document audit logging capabilities and retention policies\n\nTesting approach:\n- Review documentation with security team\n- Validate all implemented features are properly documented\n- Have developers follow guidelines to implement a test feature to verify clarity\n- Create automated tests that verify documentation examples work as described\n- Ensure all configuration options are documented with proper defaults",
          "status": "done",
          "parentTaskId": 21
        }
      ]
    },
    {
      "id": 22,
      "title": "Retrofit HIPAA Compliance to User Management System",
      "description": "Modify the existing User Management features to ensure HIPAA compliance by implementing strict RBAC, audit logging, secure handling of ePHI, and field-level encryption where necessary.",
      "details": "This task requires retrofitting HIPAA compliance onto the existing User Management system:\n\n1. **Role-Based Access Controls (RBAC)**:\n   - Implement granular permission checks for all user data access endpoints\n   - Create distinct roles (Admin, Provider, Staff, Patient) with appropriate access levels\n   - Modify all user data endpoints to verify role permissions before allowing access/modification\n   - Implement the principle of least privilege across all user operations\n\n2. **Audit Logging**:\n   - Add comprehensive audit logging for all user CRUD operations\n   - Log must include: timestamp, user ID performing action, action type, affected data, IP address\n   - Ensure logs cannot be modified or deleted by regular users\n   - Implement log rotation and secure storage policies\n\n3. **Privacy Rule Compliance**:\n   - Review all user fields to identify potential ePHI\n   - Implement data minimization practices\n   - Add consent tracking mechanisms for data usage\n   - Ensure proper disclosure limitations\n   - Add functionality for patients to request their records\n\n4. **Data Encryption**:\n   - Implement field-level encryption for sensitive user data (SSN, DOB, medical record numbers)\n   - Use industry-standard encryption algorithms (AES-256)\n   - Implement proper key management\n   - Ensure data is encrypted both at rest and in transit\n\nRefer to docs/healthcare-compliance.md for complete requirements. This implementation must be done without disrupting existing functionality. Adapt all database operations to work with libSQL/SQLite, including any changes to data types, constraints, and query syntax.",
      "testStrategy": "Testing should verify HIPAA compliance across all aspects of the User Management system:\n\n1. **RBAC Testing**:\n   - Create test users for each role (Admin, Provider, Staff, Patient)\n   - Verify each role can only access permitted data and operations\n   - Test boundary cases where permissions overlap\n   - Attempt unauthorized access and verify proper rejection\n   - Verify role elevation requires proper authentication\n\n2. **Audit Logging Tests**:\n   - Verify all user CRUD operations generate appropriate audit logs\n   - Validate log content includes all required fields\n   - Test log integrity by attempting to modify logs\n   - Verify log retention policies are enforced\n   - Test log search and retrieval functionality\n\n3. **Privacy Compliance Tests**:\n   - Verify patient data access requests work correctly\n   - Test consent management functionality\n   - Verify data minimization in API responses\n   - Test disclosure limitation mechanisms\n\n4. **Encryption Tests**:\n   - Verify sensitive fields are properly encrypted in database\n   - Test that encrypted data can be properly decrypted with appropriate access\n   - Verify encryption in transit using network analysis tools\n   - Test key rotation procedures\n\n5. **Integration Tests**:\n   - Verify all existing functionality continues to work with new compliance features\n   - Test performance impact of added security measures\n   - Conduct penetration testing to identify potential vulnerabilities\n   - Test compatibility with libSQL/SQLite, particularly for complex queries and transactions\n\nAll tests should be documented for compliance auditing purposes.",
      "status": "pending",
      "dependencies": [
        4
      ],
      "priority": "high",
      "subtasks": [
        {
          "id": 1,
          "title": "Implement Role-Based Access Control (RBAC) Framework",
          "description": "Create a comprehensive RBAC system with defined roles, permissions, and access control mechanisms",
          "dependencies": [],
          "details": "Implementation steps:\n1. Define role entities (Admin, Provider, Staff, Patient) in the database schema\n2. Create a permissions table with granular access controls for different operations\n3. Implement a role-permission mapping system\n4. Create middleware for permission verification on all user data endpoints\n5. Modify existing user service to incorporate role checks before data access\n6. Update user creation/modification flows to assign appropriate roles\n7. Implement the principle of least privilege by default\n8. Adapt database schema and queries to work with libSQL/SQLite\n\nTesting approach:\n- Unit tests for each role's permission boundaries\n- Integration tests verifying endpoint access control\n- Test cases for permission inheritance and role transitions\n- Verify existing functionality remains intact with new permission checks\n- Test compatibility with libSQL/SQLite database",
          "status": "pending",
          "parentTaskId": 22
        },
        {
          "id": 2,
          "title": "Implement Comprehensive Audit Logging System",
          "description": "Create a robust audit logging system that tracks all user-related operations with HIPAA-compliant detail level",
          "dependencies": [
            1
          ],
          "details": "Implementation steps:\n1. Design audit log schema with required HIPAA fields (timestamp, user ID, action type, affected data, IP address)\n2. Create a centralized logging service that interfaces with all user operations\n3. Implement aspect-oriented programming or middleware to intercept all user CRUD operations\n4. Add secure storage mechanisms for audit logs with appropriate retention policies\n5. Implement log rotation and archiving functionality\n6. Create admin-only interfaces for log review with appropriate filtering\n7. Ensure logs are tamper-evident and cannot be modified by regular users\n8. Adapt logging system to use libSQL/SQLite for storage\n\nTesting approach:\n- Verify all user operations generate appropriate audit entries\n- Test log rotation and retention policies\n- Validate log integrity and tamper protection\n- Performance testing to ensure logging doesn't impact system responsiveness\n- Verify log search and filtering capabilities\n- Test compatibility with libSQL/SQLite for log storage and retrieval",
          "status": "pending",
          "parentTaskId": 22
        },
        {
          "id": 3,
          "title": "Implement Field-Level Encryption for Sensitive Data",
          "description": "Add encryption for sensitive user data fields using industry-standard algorithms and proper key management",
          "dependencies": [
            1
          ],
          "details": "Implementation steps:\n1. Identify all fields containing ePHI or sensitive information (SSN, DOB, medical record numbers, etc.)\n2. Design database schema modifications to store encrypted data\n3. Implement AES-256 encryption service with proper key management\n4. Create data access layer that handles transparent encryption/decryption\n5. Modify existing APIs to use the encryption service\n6. Implement key rotation and management policies\n7. Ensure all data is encrypted both at rest and in transit\n8. Add encryption indicators in the database schema\n9. Adapt encryption implementation to work with libSQL/SQLite data types\n\nTesting approach:\n- Unit tests for encryption/decryption operations\n- Verify data is properly encrypted in the database\n- Test key rotation procedures\n- Performance testing for encryption overhead\n- Verify existing functionality with encrypted data\n- Security testing to ensure encryption implementation is sound\n- Test compatibility with libSQL/SQLite for storing and retrieving encrypted data",
          "status": "pending",
          "parentTaskId": 22
        },
        {
          "id": 4,
          "title": "Implement Privacy Rule Compliance Features",
          "description": "Add functionality for consent tracking, data minimization, and patient data access requests",
          "dependencies": [
            1,
            2,
            3
          ],
          "details": "Implementation steps:\n1. Review all user fields to identify and classify ePHI data\n2. Implement data minimization by modifying schemas and services to only collect necessary information\n3. Create consent tracking system for data usage with versioning\n4. Develop patient portal features for requesting their records\n5. Implement disclosure limitation mechanisms\n6. Add functionality to track and honor patient preferences for communications\n7. Create data retention policies and automated enforcement\n8. Implement data export functionality for patient record requests\n9. Adapt consent tracking system to use libSQL/SQLite for storage\n\nTesting approach:\n- Verify consent tracking across user operations\n- Test patient record request workflow\n- Validate data minimization implementation\n- Test disclosure limitation mechanisms\n- Verify patient communication preferences are honored\n- Test data retention policy enforcement\n- Test compatibility with libSQL/SQLite for consent tracking and data export",
          "status": "pending",
          "parentTaskId": 22
        },
        {
          "id": 5,
          "title": "Integration Testing and HIPAA Compliance Verification",
          "description": "Perform comprehensive testing of all HIPAA compliance features and ensure seamless integration with existing functionality",
          "dependencies": [
            1,
            2,
            3,
            4
          ],
          "details": "Implementation steps:\n1. Create comprehensive test plan covering all HIPAA compliance requirements\n2. Develop integration tests for all modified components\n3. Perform security testing including penetration testing on the modified system\n4. Verify all existing functionality remains intact\n5. Create documentation for HIPAA compliance features\n6. Implement automated compliance checks as part of CI/CD pipeline\n7. Perform user acceptance testing with stakeholders\n8. Create training materials for system users on new HIPAA features\n9. Test compatibility with libSQL/SQLite across all features\n\nTesting approach:\n- End-to-end testing of complete user workflows\n- Security testing including penetration testing\n- Performance testing under various load conditions\n- Compliance verification against HIPAA requirements\n- User acceptance testing with different user roles\n- Regression testing of all existing functionality\n- Database compatibility testing with libSQL/SQLite",
          "status": "pending",
          "parentTaskId": 22
        }
      ]
    },
    {
      "id": 23,
      "title": "Retrofit HIPAA Compliance to Authentication System",
      "description": "Modify the existing authentication system to ensure HIPAA compliance by implementing secure session management, audit logging, evaluating MFA options, and enhancing credential security throughout the application.",
      "details": "This task requires updating the authentication system to meet HIPAA security requirements:\n\n1. Secure Session Management:\n   - Implement strict session timeouts (15-30 minutes of inactivity)\n   - Develop secure token handling with proper encryption\n   - Ensure tokens are invalidated on logout and timeout\n   - Add automatic session termination after a defined period (8-12 hours max)\n\n2. Comprehensive Audit Logging:\n   - Create detailed audit logs for all authentication events\n   - Log login attempts (both successful and failed)\n   - Track registration activities\n   - Record password changes and reset requests\n   - Ensure logs include timestamp, user ID, IP address, and action type\n   - Implement tamper-evident logging mechanisms\n\n3. Multi-Factor Authentication:\n   - Evaluate MFA options (SMS, email, authenticator apps, hardware tokens)\n   - Implement the selected MFA solution\n   - Create recovery mechanisms for MFA\n   - Make MFA configurable (required/optional) based on user role\n\n4. Secure Credential Handling:\n   - Review and update password hashing algorithms (use bcrypt or Argon2)\n   - Implement password complexity requirements\n   - Ensure credentials are never logged or stored in plaintext\n   - Add protection against brute force attacks (account lockouts)\n   - Secure the password reset workflow\n\nRefer to docs/healthcare-compliance.md for specific HIPAA requirements and implementation guidelines. All changes must maintain backward compatibility with existing authentication flows while enhancing security. Adapt all database operations to work with libSQL/SQLite, including any changes to data types, constraints, and query syntax.",
      "testStrategy": "Testing should verify both security compliance and functionality:\n\n1. Session Management Tests:\n   - Verify sessions expire after the configured inactivity period\n   - Confirm tokens are properly invalidated on logout\n   - Test that expired tokens cannot be reused\n   - Validate that concurrent sessions are handled according to policy\n\n2. Audit Logging Tests:\n   - Verify all required authentication events are logged with correct details\n   - Test log integrity and tamper resistance\n   - Confirm logs contain all required HIPAA fields\n   - Validate log storage and retention meets compliance requirements\n\n3. MFA Testing:\n   - Test each implemented MFA method for proper functionality\n   - Verify MFA bypass attempts are blocked and logged\n   - Test MFA recovery workflows\n   - Confirm MFA enforcement based on user role configuration\n\n4. Security Testing:\n   - Conduct penetration testing focused on authentication\n   - Perform automated security scanning\n   - Test password policies enforcement\n   - Verify protection against common attacks (brute force, credential stuffing)\n   - Ensure no credentials are exposed in logs or error messages\n\n5. Compliance Validation:\n   - Create a compliance checklist based on HIPAA requirements\n   - Perform a formal review against this checklist\n   - Document evidence of compliance for each requirement\n\n6. Database Compatibility Testing:\n   - Verify all authentication operations work correctly with libSQL/SQLite\n   - Test performance of authentication queries with the new database\n   - Ensure transaction integrity for critical authentication operations\n\nAll tests should be automated where possible and included in the CI/CD pipeline.",
      "status": "pending",
      "dependencies": [
        5
      ],
      "priority": "high",
      "subtasks": [
        {
          "id": 1,
          "title": "Implement Secure Session Management",
          "description": "Update the authentication system with HIPAA-compliant session handling including timeouts, secure token management, and automatic session termination.",
          "dependencies": [],
          "details": "Implementation steps:\n1. Configure session timeout settings to automatically log users out after 15-30 minutes of inactivity\n2. Implement secure token generation using industry-standard encryption (JWT with appropriate algorithms)\n3. Update the token storage mechanism to use HttpOnly and Secure cookies\n4. Add token validation logic to check expiration and integrity on each request\n5. Implement token invalidation on user logout\n6. Add absolute session expiration after 8-12 hours regardless of activity\n7. Create session refresh mechanism that generates new tokens when appropriate\n8. Adapt token storage and validation to work with libSQL/SQLite\n\nTesting approach:\n- Unit test the token generation, validation, and expiration logic\n- Create integration tests for session timeout scenarios\n- Test logout flows to verify tokens are properly invalidated\n- Verify session expiration works correctly across different browsers\n- Test compatibility with libSQL/SQLite for token storage and validation",
          "status": "pending",
          "parentTaskId": 23
        },
        {
          "id": 2,
          "title": "Develop Comprehensive Audit Logging System",
          "description": "Create a robust audit logging system that captures all authentication-related events with appropriate details for HIPAA compliance.",
          "dependencies": [
            1
          ],
          "details": "Implementation steps:\n1. Design a structured log format that includes timestamp, user ID, IP address, action type, and result\n2. Implement logging interceptors/middleware to capture authentication events\n3. Add logging for all key events: login attempts, logouts, registration, password changes/resets\n4. Ensure failed authentication attempts are logged with appropriate details\n5. Implement tamper-evident mechanisms (e.g., cryptographic signatures or sequential IDs)\n6. Create a secure storage mechanism for logs with appropriate retention policies\n7. Add log rotation and archiving capabilities\n8. Adapt logging system to use libSQL/SQLite for storage\n\nTesting approach:\n- Unit test the logging components to ensure they capture all required fields\n- Create integration tests that verify logs are generated for each authentication event\n- Test log integrity mechanisms to ensure logs cannot be modified\n- Verify log storage and rotation works correctly\n- Test compatibility with libSQL/SQLite for log storage and retrieval",
          "status": "pending",
          "parentTaskId": 23
        },
        {
          "id": 3,
          "title": "Enhance Secure Credential Handling",
          "description": "Update password storage, validation, and reset workflows to meet HIPAA security requirements.",
          "dependencies": [],
          "details": "Implementation steps:\n1. Review and update password hashing algorithm to use bcrypt or Argon2 with appropriate work factors\n2. Implement password complexity requirements (minimum length, character types, etc.)\n3. Create a migration plan for existing password hashes\n4. Add brute force protection with account lockout after multiple failed attempts\n5. Update password reset workflow with secure token generation and expiration\n6. Ensure all credential handling code prevents plaintext storage or logging\n7. Implement secure password change functionality with current password verification\n8. Adapt credential storage to work with libSQL/SQLite data types and constraints\n\nTesting approach:\n- Unit test password hashing and validation logic\n- Test password complexity validation rules\n- Create integration tests for the password reset workflow\n- Verify account lockout functionality works correctly\n- Test migration of existing password hashes\n- Test compatibility with libSQL/SQLite for credential storage and retrieval",
          "status": "pending",
          "parentTaskId": 23
        },
        {
          "id": 4,
          "title": "Evaluate and Implement Multi-Factor Authentication",
          "description": "Research MFA options, select an appropriate solution, and implement it within the authentication system.",
          "dependencies": [
            1,
            3
          ],
          "details": "Implementation steps:\n1. Research and evaluate MFA options (SMS, email, authenticator apps, hardware tokens)\n2. Document pros/cons of each approach and select the most appropriate solution\n3. Design the MFA enrollment and verification workflows\n4. Implement the selected MFA solution with appropriate libraries/services\n5. Create recovery mechanisms for users who lose MFA access\n6. Make MFA configurable based on user roles (required for admin/clinical, optional for others)\n7. Update login flow to incorporate MFA verification step\n8. Adapt MFA configuration storage to work with libSQL/SQLite\n\nTesting approach:\n- Create unit tests for MFA verification logic\n- Develop integration tests for the complete MFA workflow\n- Test recovery mechanisms for various scenarios\n- Verify role-based MFA requirements work correctly\n- Test backward compatibility with existing authentication flows\n- Test compatibility with libSQL/SQLite for MFA configuration storage",
          "status": "pending",
          "parentTaskId": 23
        },
        {
          "id": 5,
          "title": "Integrate and Test Complete HIPAA-Compliant Authentication System",
          "description": "Integrate all authentication components, ensure they work together seamlessly, and verify HIPAA compliance across the system.",
          "dependencies": [
            1,
            2,
            3,
            4
          ],
          "details": "Implementation steps:\n1. Integrate all authentication components (session management, audit logging, credential handling, MFA)\n2. Create comprehensive documentation for the updated authentication system\n3. Develop a HIPAA compliance checklist and verify all requirements are met\n4. Perform security review of the complete authentication system\n5. Update user-facing documentation and help resources\n6. Create a rollout plan with fallback options\n7. Implement monitoring for authentication-related security events\n8. Test complete system compatibility with libSQL/SQLite\n\nTesting approach:\n- Conduct end-to-end testing of all authentication flows\n- Perform security testing (penetration testing) on the authentication system\n- Test all error handling and edge cases\n- Verify audit logs capture all required information across the system\n- Conduct user acceptance testing with different user roles\n- Verify backward compatibility with existing integrations\n- Test database performance and reliability with libSQL/SQLite",
          "status": "pending",
          "parentTaskId": 23
        }
      ]
    },
    {
      "id": 24,
      "title": "Retrofit HIPAA Compliance to Company and Office Management Features",
      "description": "Implement HIPAA compliance measures for existing Company and Office Management functionality by adding Role-Based Access Controls (RBAC) and comprehensive audit logging for all data operations.",
      "details": "This task requires modifying the existing Company and Office Management features to ensure HIPAA compliance by:\n\n1. Implementing strict Role-Based Access Controls (RBAC):\n   - Restrict company/office management capabilities to users with Admin role only\n   - Modify all controller endpoints to verify user permissions before allowing operations\n   - Update UI components to hide management options from unauthorized users\n   - Create permission constants in a central location for consistency\n\n2. Adding comprehensive audit logging:\n   - Implement detailed audit trails for all company/office CRUD operations\n   - Log must include: timestamp, user ID, action type, affected entity, before/after states\n   - Ensure logs are tamper-evident and cannot be modified\n   - Store logs in a separate, secure database table with appropriate retention policies\n\n3. Data access patterns:\n   - Implement data access filters at the repository/service layer to enforce permissions\n   - Add middleware to verify permissions for all API routes related to companies/offices\n\n4. Documentation updates:\n   - Update API documentation to reflect new permission requirements\n   - Document the audit logging format and retention policies\n\nRefer to docs/healthcare-compliance.md for specific HIPAA requirements and implementation guidelines. This work builds upon the existing Company and Office Management features from Task 6. Adapt all database operations to work with libSQL/SQLite, including any changes to data types, constraints, and query syntax.",
      "testStrategy": "Testing should verify both the RBAC implementation and audit logging functionality:\n\n1. RBAC Testing:\n   - Unit tests for each permission check in services and controllers\n   - Integration tests that verify users with Admin role can perform all operations\n   - Integration tests that verify users without Admin role receive 403 Forbidden responses\n   - UI tests to confirm management options are only visible to authorized users\n\n2. Audit Logging Tests:\n   - Unit tests to verify log entries are created for each CRUD operation\n   - Tests to verify log entries contain all required fields (timestamp, user, action, etc.)\n   - Integration tests that perform operations and verify corresponding log entries\n   - Tests to verify logs cannot be modified or deleted through normal application interfaces\n\n3. Security Testing:\n   - Attempt to bypass RBAC by directly calling APIs with unauthorized credentials\n   - Verify that all routes are protected, including any that might have been overlooked\n   - Test for SQL injection and other security vulnerabilities in the logging system\n\n4. Compliance Verification:\n   - Create a compliance checklist based on docs/healthcare-compliance.md\n   - Verify each requirement is met through manual testing\n   - Document evidence of compliance for each requirement\n\n5. Database Compatibility Testing:\n   - Verify all operations work correctly with libSQL/SQLite\n   - Test performance of queries with the new database\n   - Ensure transaction integrity for critical operations",
      "status": "pending",
      "dependencies": [
        6
      ],
      "priority": "high",
      "subtasks": [
        {
          "id": 1,
          "title": "Create RBAC Permission Constants and Core Infrastructure",
          "description": "Establish the foundation for HIPAA compliance by creating permission constants and the core infrastructure needed for role-based access controls.",
          "dependencies": [],
          "details": "Implementation steps:\n1. Create a new `permissions.js` file in a central location to define all permission constants related to company and office management (e.g., `VIEW_COMPANY`, `EDIT_COMPANY`, `DELETE_COMPANY`, etc.)\n2. Create a `RolePermissionService` that maps roles to permissions (Admin role should have all company/office management permissions)\n3. Implement a `PermissionChecker` utility that can verify if a user has a specific permission based on their role\n4. Create middleware function `verifyPermission(requiredPermission)` that can be applied to routes to check permissions\n5. Set up the database schema for the audit logging table with fields: id, timestamp, userId, action, entityType, entityId, previousState, newState\n6. Adapt database schema to use libSQL/SQLite data types and constraints\n\nTesting approach:\n- Unit test the permission mapping to ensure Admin role has all required permissions\n- Test the PermissionChecker with various role/permission combinations\n- Verify the middleware correctly blocks/allows requests based on permissions\n- Test compatibility with libSQL/SQLite database",
          "status": "pending",
          "parentTaskId": 24
        },
        {
          "id": 2,
          "title": "Implement Audit Logging Service",
          "description": "Create a comprehensive audit logging service that records all company and office management operations with required HIPAA-compliant details.",
          "dependencies": [
            1
          ],
          "details": "Implementation steps:\n1. Create an `AuditLogService` with methods to log different types of operations (create, read, update, delete)\n2. Implement functions to capture and format the before/after states of entities for change tracking\n3. Add encryption for sensitive data in the logs to ensure they're tamper-evident\n4. Implement log retention policies according to HIPAA requirements (minimum 6 years)\n5. Create database access methods for storing and retrieving audit logs\n6. Add a method to verify log integrity to detect any tampering attempts\n7. Adapt logging service to use libSQL/SQLite for storage\n\nTesting approach:\n- Unit test the logging service with mock data for all CRUD operations\n- Verify that before/after states are correctly captured and stored\n- Test the encryption and tamper detection mechanisms\n- Ensure log retention policies are correctly applied\n- Test compatibility with libSQL/SQLite for log storage and retrieval",
          "status": "pending",
          "parentTaskId": 24
        },
        {
          "id": 3,
          "title": "Modify Company Management Controllers and Services",
          "description": "Update the company management controllers and services to enforce RBAC and implement audit logging for all operations.",
          "dependencies": [
            1,
            2
          ],
          "details": "Implementation steps:\n1. Apply the `verifyPermission` middleware to all company management routes with appropriate permission requirements\n2. Modify the CompanyService to check permissions at the service layer before performing operations\n3. Integrate the AuditLogService into all company CRUD operations to log actions with required details\n4. Update repository methods to capture before/after states for audit logging\n5. Implement data access filters at the repository layer to enforce permissions\n6. Update error handling to provide appropriate responses for permission denied scenarios\n7. Adapt database queries to use libSQL/SQLite syntax\n\nTesting approach:\n- Integration tests for each endpoint with different user roles to verify permission enforcement\n- Verify audit logs are created for all operations with correct details\n- Test error scenarios and permission denied cases\n- Ensure data access filters correctly restrict data based on permissions\n- Test compatibility with libSQL/SQLite for all database operations",
          "status": "pending",
          "parentTaskId": 24
        },
        {
          "id": 4,
          "title": "Modify Office Management Controllers and Services",
          "description": "Update the office management controllers and services to enforce RBAC and implement audit logging for all operations.",
          "dependencies": [
            1,
            2
          ],
          "details": "Implementation steps:\n1. Apply the `verifyPermission` middleware to all office management routes with appropriate permission requirements\n2. Modify the OfficeService to check permissions at the service layer before performing operations\n3. Integrate the AuditLogService into all office CRUD operations to log actions with required details\n4. Update repository methods to capture before/after states for audit logging\n5. Implement data access filters at the repository layer to enforce permissions\n6. Update error handling to provide appropriate responses for permission denied scenarios\n7. Adapt database queries to use libSQL/SQLite syntax\n\nTesting approach:\n- Integration tests for each endpoint with different user roles to verify permission enforcement\n- Verify audit logs are created for all operations with correct details\n- Test error scenarios and permission denied cases\n- Ensure data access filters correctly restrict data based on permissions\n- Test compatibility with libSQL/SQLite for all database operations",
          "status": "pending",
          "parentTaskId": 24
        },
        {
          "id": 5,
          "title": "Update UI Components and Documentation",
          "description": "Update UI components to hide management options from unauthorized users and create comprehensive documentation for the HIPAA compliance implementation.",
          "dependencies": [
            3,
            4
          ],
          "details": "Implementation steps:\n1. Modify company and office management UI components to check user permissions before rendering management options\n2. Add client-side permission checking utility that mirrors the server-side permission structure\n3. Update API documentation to reflect new permission requirements for all endpoints\n4. Document the audit logging format, fields, and retention policies\n5. Create developer documentation explaining the RBAC implementation and how to properly use it for new features\n6. Update the healthcare-compliance.md document with details on how the implementation satisfies HIPAA requirements\n7. Document any libSQL/SQLite specific considerations for developers\n\nTesting approach:\n- UI tests to verify management options are only visible to authorized users\n- Manual testing of UI with different user roles\n- Review documentation for completeness and accuracy\n- Verify that all HIPAA compliance requirements from the original task are addressed in the documentation",
          "status": "pending",
          "parentTaskId": 24
        }
      ]
    },
    {
      "id": 25,
      "title": "Retrofit HIPAA Compliance for Media Handling System",
      "description": "Modify the existing S3/MinIO media handling features to ensure HIPAA compliance by implementing secure access controls, encryption, audit logging, and secure transmission protocols for media files that may contain or be linked to ePHI.",
      "details": "This task requires updating the existing media handling system to meet HIPAA compliance requirements as outlined in docs/healthcare-compliance.md. Specific implementation details include:\n\n1. Access Controls:\n   - Implement role-based access control (RBAC) for all media files\n   - Create permission checks before any media access, ensuring only authorized users can view/download files\n   - Add patient-provider relationship validation before granting access to therapy-related media\n   - Implement time-limited access tokens for temporary file access\n\n2. Encryption:\n   - Configure server-side encryption (SSE) for all files stored in S3/MinIO\n   - Implement AES-256 encryption standard\n   - Establish secure key management procedures\n   - Ensure encryption at rest for all stored media\n\n3. Audit Logging:\n   - Create comprehensive audit logs capturing all media interactions:\n     - File uploads (who, when, file metadata)\n     - File access/downloads (who, when, access context)\n     - File modifications or deletions\n   - Ensure logs contain sufficient detail for compliance reporting\n   - Make logs tamper-evident and immutable\n   - Implement log retention policies per HIPAA requirements\n\n4. Secure Transmission:\n   - Enforce HTTPS/TLS 1.2+ for all media transfers\n   - Implement secure URL generation with appropriate expiration\n   - Add integrity verification for uploaded/downloaded files\n\n5. Additional Requirements:\n   - Update privacy notices and terms of service\n   - Create documentation for the security measures implemented\n   - Ensure proper error handling that doesn't expose sensitive information\n\nReview the existing implementation from Task 7 and ensure all modifications maintain backward compatibility where possible. Adapt metadata storage and audit logging to use libSQL/SQLite instead of PostgreSQL, ensuring compatibility with the new database system.",
      "testStrategy": "Testing should verify all HIPAA compliance aspects of the media handling system:\n\n1. Access Control Testing:\n   - Verify unauthorized users cannot access protected media files\n   - Test that users can only access files they have permissions for\n   - Verify access tokens expire correctly and cannot be reused\n   - Test edge cases like terminated staff accounts and transferred patients\n\n2. Encryption Testing:\n   - Verify server-side encryption is properly configured\n   - Confirm encryption headers in S3/MinIO responses\n   - Attempt to access raw storage to confirm files are encrypted\n   - Validate key rotation procedures work correctly\n\n3. Audit Log Testing:\n   - Verify all media operations generate appropriate audit logs\n   - Confirm logs contain required fields (user ID, timestamp, action, resource ID)\n   - Test log integrity and immutability\n   - Verify log retention policies are enforced\n\n4. Secure Transmission Testing:\n   - Use tools like OWASP ZAP to verify secure connections\n   - Test for TLS configuration issues\n   - Verify secure URL generation and expiration\n   - Attempt to intercept traffic to confirm encryption\n\n5. Compliance Testing:\n   - Create a compliance checklist based on docs/healthcare-compliance.md\n   - Perform a security review with the compliance team\n   - Document all security measures for potential audit\n\n6. Regression Testing:\n   - Verify all existing media functionality still works\n   - Test performance impact of new security measures\n\n7. Database Compatibility Testing:\n   - Verify metadata storage works correctly with libSQL/SQLite\n   - Test audit logging with the new database system\n   - Ensure transaction integrity for critical operations\n\nCreate automated tests where possible and document manual test procedures for aspects that cannot be automated.",
      "status": "pending",
      "dependencies": [
        7
      ],
      "priority": "high",
      "subtasks": [
        {
          "id": 1,
          "title": "Implement Role-Based Access Control (RBAC) for Media Files",
          "description": "Modify the existing media handling system to implement RBAC and permission validation before any media access.",
          "dependencies": [],
          "details": "Implementation steps:\n1. Create a MediaPermission model to define access levels (read, write, delete) for user roles\n2. Implement a MediaAccessService that validates user permissions before any file operation\n3. Add patient-provider relationship validation by querying the existing relationship database\n4. Create middleware that intercepts all media requests to perform permission checks\n5. Implement time-limited access tokens for temporary file access using JWT with expiration\n6. Update existing media retrieval endpoints to use the new permission system\n7. Adapt database schema and queries to use libSQL/SQLite\n\nTesting approach:\n- Unit tests for the MediaAccessService with various permission scenarios\n- Integration tests verifying access control across the application\n- Security tests attempting unauthorized access to media files\n- Performance tests to ensure minimal overhead from permission checks\n- Test compatibility with libSQL/SQLite database",
          "status": "pending",
          "parentTaskId": 25
        },
        {
          "id": 2,
          "title": "Configure Server-Side Encryption for S3/MinIO Storage",
          "description": "Implement AES-256 encryption for all media files at rest in the storage system.",
          "dependencies": [
            1
          ],
          "details": "Implementation steps:\n1. Configure server-side encryption (SSE) settings in the S3/MinIO client\n2. Implement a secure key management service that handles encryption keys\n3. Create a key rotation mechanism that periodically updates encryption keys\n4. Modify the file upload process to ensure encryption headers are properly set\n5. Implement a system to re-encrypt existing files to meet the new standards\n6. Create a verification process that confirms files are properly encrypted\n7. Store encryption metadata in libSQL/SQLite database\n\nTesting approach:\n- Unit tests for the encryption configuration\n- Integration tests verifying files are properly encrypted when stored\n- Tests for key rotation functionality\n- Verification tests to confirm existing files are properly re-encrypted\n- Performance testing to measure impact of encryption on upload/download speeds\n- Test compatibility with libSQL/SQLite for metadata storage",
          "status": "pending",
          "parentTaskId": 25
        },
        {
          "id": 3,
          "title": "Develop Comprehensive Audit Logging System",
          "description": "Create a detailed, immutable audit logging system that captures all media interactions.",
          "dependencies": [
            1
          ],
          "details": "Implementation steps:\n1. Design and implement a MediaAuditLog model to store detailed audit information\n2. Create an AuditLogService that captures all media operations (upload, access, modification, deletion)\n3. Implement hooks in the media handling system to trigger audit logging\n4. Ensure logs contain user ID, timestamp, action type, file metadata, and access context\n5. Make logs tamper-evident by implementing digital signatures or blockchain techniques\n6. Create a log retention policy manager that archives/deletes logs according to HIPAA requirements\n7. Implement a secure log viewing interface for administrators and compliance officers\n8. Adapt logging system to use libSQL/SQLite for storage\n\nTesting approach:\n- Unit tests for the AuditLogService\n- Integration tests verifying all media operations are properly logged\n- Tests for log immutability and tamper detection\n- Performance tests to ensure logging doesn't impact system performance\n- Verification that logs contain all required HIPAA information\n- Test compatibility with libSQL/SQLite for log storage and retrieval",
          "status": "pending",
          "parentTaskId": 25
        },
        {
          "id": 4,
          "title": "Enhance Secure Transmission Protocols",
          "description": "Enforce secure transmission standards for all media file transfers.",
          "dependencies": [
            1,
            2
          ],
          "details": "Implementation steps:\n1. Enforce HTTPS/TLS 1.2+ for all media transfers by updating server configurations\n2. Implement secure URL generation with appropriate expiration times for media access\n3. Create a signed URL service that generates time-limited, authenticated access URLs\n4. Add file integrity verification using checksums for uploaded/downloaded files\n5. Implement content validation to ensure only permitted file types are uploaded\n6. Create a transmission monitoring system to detect and block insecure access attempts\n7. Store transmission metadata in libSQL/SQLite database\n\nTesting approach:\n- Security tests attempting to access media via non-HTTPS connections\n- Tests for URL expiration functionality\n- Integration tests for file integrity verification\n- Performance tests measuring impact on file transfer speeds\n- Penetration testing to identify potential security vulnerabilities\n- Test compatibility with libSQL/SQLite for metadata storage",
          "status": "pending",
          "parentTaskId": 25
        },
        {
          "id": 5,
          "title": "Update Documentation and Error Handling",
          "description": "Create comprehensive documentation and implement HIPAA-compliant error handling.",
          "dependencies": [
            1,
            2,
            3,
            4
          ],
          "details": "Implementation steps:\n1. Update privacy notices and terms of service to reflect new security measures\n2. Create technical documentation detailing all implemented security features\n3. Implement HIPAA-compliant error handling that doesn't expose sensitive information\n4. Create user guides for the secure media handling system\n5. Document the encryption standards, key management procedures, and audit logging\n6. Prepare compliance documentation showing how the system meets HIPAA requirements\n7. Create a system status dashboard showing compliance metrics\n8. Document libSQL/SQLite specific considerations for the media handling system\n\nTesting approach:\n- Review of all error messages to ensure they don't leak sensitive information\n- Validation of documentation against HIPAA requirements\n- User testing of documentation clarity\n- Verification that all implemented features are properly documented\n- Compliance officer review of the final documentation package",
          "status": "pending",
          "parentTaskId": 25
        }
      ]
    },
    {
      "id": 26,
      "title": "Retrofit HIPAA Compliance for Therapy Plan Management",
      "description": "Modify the existing Therapy Plan Management features to ensure HIPAA compliance through implementing strict RBAC, comprehensive audit logging, data encryption at rest, and secure transmission protocols.",
      "details": "This task requires retrofitting HIPAA compliance onto the existing Therapy Plan Management system (from Task 8) with the following specific requirements:\n\n1. Role-Based Access Control (RBAC):\n   - Implement granular permission system for therapy plans with distinct roles (Chiropractor/Creator, Patient, Assistant, Administrator)\n   - Enforce ownership model where plan creators have full access rights\n   - Limit patient access to view-only for assigned plans\n   - Create middleware to validate access permissions before any plan operation\n   - Implement access control checks in all plan-related API endpoints\n\n2. Audit Logging:\n   - Create comprehensive logging system capturing all plan interactions\n   - Log must include: user ID, action type, timestamp, IP address, affected resource ID, and before/after states\n   - Implement logs for plan creation, viewing, modification, assignment, and deletion\n   - Ensure exercise addition/modification/removal is logged\n   - Create admin interface for log review with filtering capabilities\n   - Ensure logs are tamper-proof and cannot be modified\n\n3. Data Encryption:\n   - Implement field-level encryption for sensitive plan data including titles, descriptions, instructions, and patient-specific notes\n   - Use industry-standard encryption algorithms (AES-256)\n   - Implement proper key management system with rotation capabilities\n   - Ensure database backups are also encrypted\n\n4. Secure Transmission:\n   - Enforce HTTPS for all API communications\n   - Implement proper Content Security Policy headers\n   - Add API rate limiting to prevent abuse\n   - Ensure all therapy plan data is encrypted during transmission\n\nRefer to docs/healthcare-compliance.md for specific HIPAA requirements and implementation guidelines. Coordinate with the security team for encryption standards and key management protocols. Adapt all database operations to work with libSQL/SQLite, including any changes to data types, constraints, and query syntax.",
      "testStrategy": "Testing should verify all HIPAA compliance aspects:\n\n1. RBAC Testing:\n   - Unit tests for each permission level (create, read, update, delete) across all roles\n   - Integration tests simulating different user roles attempting various operations\n   - Negative testing to verify unauthorized access is properly rejected\n   - Test boundary cases (e.g., transferred ownership, deactivated accounts)\n\n2. Audit Logging Verification:\n   - Verify all required events generate appropriate log entries with complete information\n   - Test log integrity by attempting to modify logs directly\n   - Validate log retention policies are enforced\n   - Test log search and filtering functionality\n   - Verify logs capture before/after states for modifications\n\n3. Encryption Testing:\n   - Verify sensitive fields are encrypted in database using direct DB inspection\n   - Test encryption/decryption performance under load\n   - Verify key rotation procedures work correctly\n   - Ensure encrypted backups can be properly restored\n\n4. Security Testing:\n   - Perform penetration testing on API endpoints\n   - Verify all communications use HTTPS with proper certificate validation\n   - Test API rate limiting functionality\n   - Conduct man-in-the-middle attack simulations to verify data cannot be intercepted\n\n5. Compliance Validation:\n   - Create comprehensive test documentation mapping each test to specific HIPAA requirements\n   - Conduct end-to-end scenario testing with realistic patient data\n   - Perform security code review focused on the implemented changes\n   - Validate against HIPAA compliance checklist from docs/healthcare-compliance.md\n\n6. Database Compatibility Testing:\n   - Verify all operations work correctly with libSQL/SQLite\n   - Test performance of complex queries with the new database\n   - Ensure transaction integrity for critical operations\n   - Test encryption compatibility with libSQL/SQLite",
      "status": "pending",
      "dependencies": [
        8
      ],
      "priority": "high",
      "subtasks": [
        {
          "id": 1,
          "title": "Implement Role-Based Access Control (RBAC) System",
          "description": "Design and implement a granular RBAC system for the Therapy Plan Management features with distinct roles and permissions.",
          "dependencies": [],
          "details": "Implementation details:\n1. Create a permission model with defined roles (Chiropractor/Creator, Patient, Assistant, Administrator)\n2. Define granular permissions for each role (create, read, update, delete, assign)\n3. Implement ownership model where plan creators have full access rights\n4. Create middleware to validate access permissions before any plan operation\n5. Modify existing API endpoints to include permission checks\n6. Update database schema to track ownership and permissions\n7. Create role assignment functionality for administrators\n8. Adapt database schema and queries to use libSQL/SQLite\n\nTesting approach:\n- Unit tests for permission validation logic\n- Integration tests for middleware functionality\n- End-to-end tests simulating different user roles accessing protected resources\n- Security penetration testing to verify unauthorized access is prevented\n- Test compatibility with libSQL/SQLite database",
          "status": "pending",
          "parentTaskId": 26
        },
        {
          "id": 2,
          "title": "Develop Comprehensive Audit Logging System",
          "description": "Create a tamper-proof audit logging system that captures all interactions with therapy plans.",
          "dependencies": [
            1
          ],
          "details": "Implementation details:\n1. Design database schema for audit logs with fields for user ID, action type, timestamp, IP address, resource ID, and before/after states\n2. Implement logging service to capture all plan interactions\n3. Add logging hooks to all plan-related operations (creation, viewing, modification, assignment, deletion)\n4. Ensure exercise addition/modification/removal is logged\n5. Implement tamper-proof mechanisms (e.g., cryptographic signatures, sequential IDs)\n6. Create admin interface for log review with filtering and search capabilities\n7. Implement log retention policies according to HIPAA requirements\n8. Adapt logging system to use libSQL/SQLite for storage\n\nTesting approach:\n- Unit tests for logging service\n- Integration tests to verify logs are created for all operations\n- Verification tests for tamper-proof mechanisms\n- UI tests for admin interface functionality\n- Performance tests to ensure logging doesn't impact system performance\n- Test compatibility with libSQL/SQLite for log storage and retrieval",
          "status": "pending",
          "parentTaskId": 26
        },
        {
          "id": 3,
          "title": "Implement Data Encryption at Rest",
          "description": "Add field-level encryption for sensitive therapy plan data using industry-standard encryption algorithms.",
          "dependencies": [
            1
          ],
          "details": "Implementation details:\n1. Identify all sensitive fields requiring encryption (plan titles, descriptions, instructions, patient notes)\n2. Implement encryption/decryption service using AES-256 algorithm\n3. Create key management system with secure storage and rotation capabilities\n4. Modify database access layer to transparently encrypt/decrypt data\n5. Update database schema to store encrypted data\n6. Ensure database backups are also encrypted\n7. Implement key rotation procedures\n8. Document encryption implementation for compliance audits\n9. Adapt encryption implementation to work with libSQL/SQLite data types\n\nTesting approach:\n- Unit tests for encryption/decryption functions\n- Integration tests verifying data is properly encrypted in database\n- Performance tests to measure impact of encryption/decryption operations\n- Security tests to verify encrypted data cannot be accessed without proper keys\n- Backup and restore tests with encrypted data\n- Test compatibility with libSQL/SQLite for storing and retrieving encrypted data",
          "status": "pending",
          "parentTaskId": 26
        },
        {
          "id": 4,
          "title": "Enhance Secure Data Transmission",
          "description": "Implement secure transmission protocols for all therapy plan data communications.",
          "dependencies": [
            1,
            3
          ],
          "details": "Implementation details:\n1. Configure and enforce HTTPS for all API communications\n2. Implement proper Content Security Policy headers\n3. Add API rate limiting to prevent abuse\n4. Implement transport layer encryption for all therapy plan data\n5. Update API endpoints to validate secure connections\n6. Configure secure cookie attributes (Secure, HttpOnly, SameSite)\n7. Implement HSTS headers\n8. Add protection against common web vulnerabilities (XSS, CSRF)\n\nTesting approach:\n- Security scans to verify HTTPS implementation\n- API tests to verify rate limiting functionality\n- Penetration testing to identify potential security vulnerabilities\n- Performance testing under rate limiting conditions\n- Compatibility testing across different browsers and clients",
          "status": "pending",
          "parentTaskId": 26
        },
        {
          "id": 5,
          "title": "Create HIPAA Compliance Documentation and Verification",
          "description": "Develop comprehensive documentation and verification procedures to ensure HIPAA compliance of the therapy plan management system.",
          "dependencies": [
            1,
            2,
            3,
            4
          ],
          "details": "Implementation details:\n1. Create detailed documentation of all implemented HIPAA compliance measures\n2. Develop verification procedures to test compliance features\n3. Implement automated compliance checks as part of CI/CD pipeline\n4. Create user training materials for HIPAA-compliant system usage\n5. Develop incident response procedures for potential data breaches\n6. Create compliance reports for auditing purposes\n7. Implement regular compliance scanning and reporting\n8. Document all security measures for regulatory review\n9. Document libSQL/SQLite specific considerations for the therapy plan management system\n\nTesting approach:\n- Comprehensive system audit against HIPAA requirements\n- Simulated breach scenarios to test incident response\n- User acceptance testing with compliance-focused scenarios\n- Documentation review by legal/compliance team\n- Verification that all requirements from healthcare-compliance.md are satisfied\n- Test database compatibility with libSQL/SQLite across all features",
          "status": "pending",
          "parentTaskId": 26
        }
      ]
    },
    {
      "id": 27,
      "title": "Migrate Database Configuration from PostgreSQL to libSQL/SQLite",
      "description": "Update the docker-compose.yml and environment variables to replace PostgreSQL with libSQL/SQLite as the database backend, following the guidelines in docs/switching-db-to-libsql.md.",
      "details": "This task involves modifying the project's database configuration to use libSQL/SQLite instead of PostgreSQL:\n\n1. Remove or comment out the 'db' service in docker-compose.yml that currently defines the PostgreSQL container\n\n2. Update the DATABASE_URL environment variable in the 'api' service to use the libSQL format:\n   - For file-based SQLite: `DATABASE_URL=sqlite:///path/to/db.sqlite`\n   - For libSQL server: `DATABASE_URL=libsql://[token]@[hostname].turso.io/[db-name]`\n\n3. Adjust volumes configuration in the 'api' service to ensure persistence of the SQLite database file if using file-based approach:\n   - Add a volume mapping like `- ./data:/app/data` if storing the SQLite file in a /data directory\n\n4. Remove any PostgreSQL-specific environment variables from the 'api' service that are no longer needed\n\n5. Update any database initialization scripts or commands in the docker-compose.yml to align with libSQL/SQLite requirements\n\n6. Ensure the libSQL/SQLite client libraries are properly installed in the application's Dockerfile or requirements file\n\n7. Document the changes made in a comment at the top of the docker-compose.yml file",
      "testStrategy": "To verify the successful migration to libSQL/SQLite:\n\n1. Run `docker-compose up -d` to start the services with the new configuration\n\n2. Check that the application starts without database connection errors in the logs: `docker-compose logs api`\n\n3. Verify the API can perform basic database operations by:\n   - Creating a test record through an API endpoint\n   - Retrieving the created record\n   - Updating the record\n   - Deleting the record\n\n4. Confirm data persistence by:\n   - Creating data through the API\n   - Stopping all containers with `docker-compose down`\n   - Starting containers again with `docker-compose up -d`\n   - Verifying the previously created data is still accessible\n\n5. If using file-based SQLite, check that the database file exists in the expected location\n\n6. Verify the application works correctly when scaled (if applicable) to ensure there are no file locking issues with SQLite\n\n7. Run the application's existing test suite to ensure all database interactions continue to function correctly",
      "status": "done",
      "dependencies": [
        1
      ],
      "priority": "medium",
      "subtasks": [
        {
          "id": 1,
          "title": "Remove PostgreSQL service from docker-compose.yml",
          "description": "Remove or comment out the 'db' service in docker-compose.yml that currently defines the PostgreSQL container and document the change.",
          "dependencies": [],
          "details": "Implementation steps:\n1. Open docker-compose.yml\n2. Locate the 'db' service section that defines the PostgreSQL container\n3. Either remove the entire section or comment it out using YAML comment syntax (# at the beginning of each line)\n4. Add a comment at the top of the file documenting the migration from PostgreSQL to libSQL/SQLite\n5. Verify the file still has valid YAML syntax after changes\n\nTesting approach:\n- Run 'docker-compose config' to validate the YAML syntax is still correct\n- Ensure the PostgreSQL container no longer starts when running 'docker-compose up'",
          "status": "done",
          "parentTaskId": 27
        },
        {
          "id": 2,
          "title": "Update DATABASE_URL environment variable for libSQL/SQLite",
          "description": "Modify the DATABASE_URL environment variable in the 'api' service to use the appropriate libSQL/SQLite connection string format.",
          "dependencies": [
            1
          ],
          "details": "Implementation steps:\n1. Open docker-compose.yml\n2. Locate the 'api' service section\n3. Find the DATABASE_URL environment variable\n4. Replace the PostgreSQL connection string with the appropriate libSQL format:\n   - For file-based SQLite: `DATABASE_URL=sqlite:///app/data/db.sqlite`\n   - For libSQL server: `DATABASE_URL=libsql://[token]@[hostname].turso.io/[db-name]`\n5. If using a remote libSQL instance, ensure any tokens or credentials are properly handled (e.g., using .env files)\n\nTesting approach:\n- Verify the connection string format matches the documentation in docs/switching-db-to-libsql.md\n- Test the connection string format with a simple database connection test",
          "status": "done",
          "parentTaskId": 27
        },
        {
          "id": 3,
          "title": "Configure volume mapping for SQLite persistence",
          "description": "Add or update volume configuration in the 'api' service to ensure SQLite database file persistence if using file-based approach.",
          "dependencies": [
            1,
            2
          ],
          "details": "Implementation steps:\n1. Open docker-compose.yml\n2. Locate the 'api' service section\n3. Find or add the 'volumes' section under the 'api' service\n4. Add a volume mapping to ensure persistence of the SQLite database file:\n   - Add `- ./data:/app/data` if storing the SQLite file in a /data directory\n5. Create the local data directory if it doesn't exist\n6. Ensure proper permissions are set on the data directory\n\nTesting approach:\n- Run 'docker-compose up' and verify the volume is correctly mounted\n- Create a test file in the mounted directory and verify it persists between container restarts\n- Check that database changes persist after container restarts",
          "status": "done",
          "parentTaskId": 27
        },
        {
          "id": 4,
          "title": "Remove PostgreSQL-specific environment variables",
          "description": "Identify and remove any PostgreSQL-specific environment variables from the 'api' service that are no longer needed with libSQL/SQLite.",
          "dependencies": [
            1,
            2
          ],
          "details": "Implementation steps:\n1. Open docker-compose.yml\n2. Locate the 'api' service section\n3. Review all environment variables and identify PostgreSQL-specific ones such as:\n   - POSTGRES_USER\n   - POSTGRES_PASSWORD\n   - POSTGRES_DB\n   - POSTGRES_HOST\n   - Any other PostgreSQL-specific configuration variables\n4. Remove or comment out these variables as they're no longer needed\n5. If there are any database initialization scripts or commands specific to PostgreSQL, update or remove them\n\nTesting approach:\n- Run 'docker-compose up' and verify the application starts without errors related to missing environment variables\n- Check application logs to ensure no PostgreSQL connection attempts are being made",
          "status": "done",
          "parentTaskId": 27
        },
        {
          "id": 5,
          "title": "Update Dockerfile to include libSQL/SQLite dependencies",
          "description": "Ensure the necessary libSQL/SQLite client libraries are properly installed in the application's Dockerfile or requirements file.",
          "dependencies": [
            1,
            2,
            3,
            4
          ],
          "details": "Implementation steps:\n1. Review docs/switching-db-to-libsql.md to identify required libraries\n2. Open the application's Dockerfile\n3. Add necessary system packages if required (e.g., sqlite3-dev)\n4. Update the application's requirements file (e.g., requirements.txt) to include:\n   - sqlalchemy with appropriate drivers\n   - libsql-client or pysqlite3 as needed\n5. If using a specific ORM, ensure compatible versions are specified\n6. Remove any PostgreSQL-specific libraries that are no longer needed\n\nTesting approach:\n- Build the Docker image with 'docker-compose build'\n- Run the application with 'docker-compose up'\n- Verify the application can connect to the libSQL/SQLite database\n- Run a simple database query to confirm functionality\n- Check application logs for any dependency or import errors",
          "status": "done",
          "parentTaskId": 27
        }
      ]
    },
    {
      "id": 28,
      "title": "Adapt SQLAlchemy Models for libSQL/SQLite Compatibility",
      "description": "Modify SQLAlchemy models in api/models/base.py to ensure compatibility with libSQL/SQLite, focusing on type affinity and storage requirements as outlined in the database migration documentation.",
      "details": "This task involves reviewing and adapting all SQLAlchemy model field types in `api/models/base.py` to ensure compatibility with libSQL/SQLite's type system. Follow section 3 of `docs/switching-db-to-libsql.md` as a guide.\n\nSpecific changes required:\n\n1. **TIMESTAMP fields**: Review all timestamp fields for timezone handling. SQLite doesn't have native timezone support, so ensure timestamps are stored consistently (likely as UTC) and that application code handles timezone conversions appropriately.\n\n2. **JSON fields**: SQLite doesn't have a native JSON type. Either:\n   - Store JSON as TEXT and handle serialization/deserialization in the application code\n   - Implement SQLAlchemy type adapters for automatic JSON conversion\n   - Consider using SQLite JSON1 extension functions for query capabilities if needed\n\n3. **String length constraints**: SQLite doesn't enforce VARCHAR length constraints. Ensure all String fields with length limits rely on application-level validation rather than database constraints.\n\n4. **EncryptedType**: Verify that all EncryptedType fields correctly map to TEXT type in SQLite and that the encryption/decryption process works with SQLite's storage format.\n\n5. **Other field types**: Review all other field types (Integer, Boolean, etc.) to ensure they map correctly to SQLite's type affinity system.\n\nUpdate model definitions as needed, maintaining backward compatibility where possible. Document any changes that might affect application behavior or require data migration.",
      "testStrategy": "1. **Unit Tests**: Create or update unit tests for each model to verify field types are correctly defined and behave as expected with SQLite:\n   - Test serialization/deserialization of JSON fields\n   - Test timezone handling in timestamp fields\n   - Test string fields with various lengths and character sets\n   - Test EncryptedType fields for proper encryption/decryption\n\n2. **Integration Testing**:\n   - Set up a test database using libSQL/SQLite\n   - Run model migrations against this database\n   - Verify all tables and columns are created with correct types\n   - Test CRUD operations on each model with various data types\n\n3. **Validation Testing**:\n   - Test edge cases for each field type (empty strings, NULL values, very large JSON objects)\n   - Verify application-level validation works for string length constraints\n   - Test timezone edge cases (daylight saving transitions, UTC offsets)\n\n4. **Regression Testing**:\n   - Ensure existing functionality works with the updated models\n   - Verify no unexpected behavior changes in query results\n\nDocument any SQLite-specific behaviors or limitations discovered during testing.",
      "status": "done",
      "dependencies": [
        27
      ],
      "priority": "medium",
      "subtasks": [
        {
          "id": 1,
          "title": "Analyze and document current SQLAlchemy model field types",
          "description": "Create a comprehensive inventory of all field types used in SQLAlchemy models in api/models/base.py, documenting their current configuration and identifying potential compatibility issues with libSQL/SQLite.",
          "dependencies": [],
          "details": "Implementation steps:\n1. Review api/models/base.py and identify all model classes and their field definitions\n2. Create a structured document listing each field type used (TIMESTAMP, JSON, String, EncryptedType, etc.)\n3. For each field type, document:\n   - How it's currently defined\n   - The SQLAlchemy type used\n   - Any constraints or special handling\n   - Potential libSQL/SQLite compatibility issues based on docs/switching-db-to-libsql.md\n4. Identify fields that will need modification\n5. Test by validating the document against the actual codebase to ensure all field types are covered\n\nTesting approach: Perform a code review to ensure all model fields are documented and all potential compatibility issues are identified.",
          "status": "done",
          "parentTaskId": 28
        },
        {
          "id": 2,
          "title": "Implement TIMESTAMP field compatibility adaptations",
          "description": "Modify all timestamp fields in the SQLAlchemy models to ensure proper handling with libSQL/SQLite, focusing on timezone handling and storage format.",
          "dependencies": [
            1
          ],
          "details": "Implementation steps:\n1. Based on the analysis from subtask 1, identify all TIMESTAMP fields in the models\n2. Modify each timestamp field to ensure it stores data in UTC format\n3. Update field definitions to use appropriate SQLAlchemy types that are compatible with SQLite (likely DateTime without timezone)\n4. Add application-level handling for timezone conversions where needed\n5. Document the changes made to each timestamp field\n6. Create unit tests to verify timestamp storage and retrieval works correctly with both PostgreSQL and SQLite\n\nTesting approach:\n- Write unit tests that create and retrieve objects with timestamp fields\n- Verify correct timezone handling across database backends\n- Test edge cases like DST transitions and timezone conversions",
          "status": "done",
          "parentTaskId": 28
        },
        {
          "id": 3,
          "title": "Adapt JSON field handling for SQLite compatibility",
          "description": "Modify all JSON fields in the SQLAlchemy models to work with SQLite's lack of native JSON type, implementing proper serialization/deserialization mechanisms.",
          "dependencies": [
            1
          ],
          "details": "Implementation steps:\n1. Based on the analysis from subtask 1, identify all JSON fields in the models\n2. Create a custom SQLAlchemy type adapter that:\n   - Stores JSON as TEXT in SQLite\n   - Handles serialization when writing to the database\n   - Handles deserialization when reading from the database\n3. Replace all existing JSON field definitions with the new custom type\n4. If query capabilities are needed, implement functions that utilize SQLite JSON1 extension\n5. Update any code that directly interacts with these JSON fields\n6. Document the implementation approach and any limitations\n\nTesting approach:\n- Create unit tests that store and retrieve complex JSON structures\n- Test JSON query functionality if implemented\n- Verify compatibility with both PostgreSQL and SQLite backends",
          "status": "done",
          "parentTaskId": 28
        },
        {
          "id": 4,
          "title": "Update String fields and EncryptedType for SQLite compatibility",
          "description": "Modify String fields with length constraints and EncryptedType fields to ensure they work correctly with SQLite's type system and storage format.",
          "dependencies": [
            1
          ],
          "details": "Implementation steps:\n1. Based on the analysis from subtask 1, identify all String fields with length constraints\n2. Implement application-level validation for string length since SQLite doesn't enforce VARCHAR length\n3. Update String field definitions to work with SQLite while maintaining PostgreSQL compatibility\n4. Identify all EncryptedType fields in the models\n5. Verify and modify EncryptedType implementation to ensure it correctly maps to TEXT in SQLite\n6. Test the encryption/decryption process with SQLite's storage format\n7. Document all changes made to String and EncryptedType fields\n\nTesting approach:\n- Create unit tests for string length validation\n- Test storing and retrieving encrypted data\n- Verify data integrity across database backends\n- Test edge cases like empty strings and maximum length strings",
          "status": "done",
          "parentTaskId": 28
        },
        {
          "id": 5,
          "title": "Review and adapt remaining field types for SQLite compatibility",
          "description": "Review all other field types (Integer, Boolean, etc.) to ensure they map correctly to SQLite's type affinity system and implement any necessary changes.",
          "dependencies": [
            1,
            2,
            3,
            4
          ],
          "details": "Implementation steps:\n1. Based on the analysis from subtask 1, identify all remaining field types not covered in previous subtasks\n2. For each field type, review how it maps to SQLite's type affinity system\n3. Implement necessary changes to ensure correct behavior with SQLite\n4. Pay special attention to:\n   - Boolean fields (stored as integers in SQLite)\n   - Enum types\n   - Any custom field types\n   - Foreign keys and relationships\n5. Create a comprehensive test suite that validates all field types work correctly\n6. Document all changes made and any potential impacts on application behavior\n7. Update the database migration documentation with any new findings or recommendations\n\nTesting approach:\n- Create a test suite that exercises all field types\n- Test with both PostgreSQL and SQLite backends\n- Verify data integrity and type conversion\n- Test application functionality that relies on these fields",
          "status": "done",
          "parentTaskId": 28
        }
      ]
    },
    {
      "id": 29,
      "title": "Overhaul Alembic Migrations for libSQL/SQLite Compatibility",
      "description": "Reset the migration history by removing all existing migration files and generating a single initial migration that reflects the libSQL-compatible database models using the new custom migration tool.",
      "status": "pending",
      "dependencies": [
        28,
        33
      ],
      "priority": "high",
      "details": "Following Option B from section 4 of `docs/switching-db-to-libsql.md`, this task involves:\n\n1. Back up the existing migration files in `alembic/versions/` directory to a separate location (for reference purposes)\n2. Delete all migration script files from the `alembic/versions/` directory\n3. Ensure all SQLAlchemy models have been properly adapted for libSQL/SQLite compatibility (dependent on Task 28)\n4. Generate a new initial migration using the custom migration tool (developed in Task 33)\n5. Review the generated migration file to ensure it correctly captures all model definitions\n6. Update any documentation that references specific migration versions\n7. Configure the custom migration tool for proper libSQL integration\n8. Test the migration by applying it to a fresh database\n\nNote: This approach will erase the previous migration history, meaning that existing databases cannot be upgraded using the standard upgrade path. A separate data migration strategy may be needed for production environments.",
      "testStrategy": "1. Create a fresh libSQL/SQLite database\n2. Run the custom migration tool to apply the new initial migration\n3. Verify that all tables, columns, indexes, and constraints are created correctly by:\n   - Inspecting the database schema using SQLite tools or commands\n   - Comparing the actual schema with the expected schema based on the models\n   - Ensuring all model classes can be instantiated and saved to the database\n4. Test rollback functionality with the custom migration tool\n5. Verify the application can connect to and operate with the new database schema by:\n   - Running a subset of existing integration tests against the new schema\n   - Performing CRUD operations on all major entities\n   - Testing any complex queries that might be affected by SQLite's limitations\n6. Document any schema differences between the previous PostgreSQL schema and the new SQLite schema",
      "subtasks": [
        {
          "id": 1,
          "title": "Back up and clean existing Alembic migration files",
          "description": "Create a backup of all existing migration files in the alembic/versions/ directory and then remove them from the active project directory.",
          "dependencies": [],
          "details": "Implementation steps:\n1. Create a backup directory outside the project structure (e.g., 'alembic_backup/')\n2. Copy all files from 'alembic/versions/' to the backup directory with their original filenames and timestamps preserved\n3. Document the backup location in a README file within the backup directory\n4. Remove all migration script files from the 'alembic/versions/' directory\n5. Verify the directory is empty except for any necessary __init__.py file\n\nTesting approach:\n- Confirm all files were properly backed up by comparing file counts and checksums\n- Verify the alembic/versions/ directory is properly cleaned",
          "status": "done",
          "parentTaskId": 29
        },
        {
          "id": 2,
          "title": "Update Alembic environment configuration for libSQL",
          "description": "Modify the Alembic environment configuration in env.py to ensure proper compatibility with libSQL/SQLite.",
          "dependencies": [
            1
          ],
          "details": "Implementation steps:\n1. Review the current env.py file in the Alembic directory\n2. Update the database URL handling to properly connect to libSQL/SQLite\n3. Modify any SQLAlchemy configuration options that need adjustment for libSQL compatibility\n4. Ensure proper handling of SQLite-specific constraints and types\n5. Add comments explaining the libSQL-specific configurations\n6. Update any render_item or include_object functions to handle SQLite-specific schema elements\n\nTesting approach:\n- Run a basic Alembic command like 'alembic current' to verify the configuration works\n- Check logs for any SQLite-specific warnings or errors",
          "status": "done",
          "parentTaskId": 29
        },
        {
          "id": 3,
          "title": "Generate new initial migration for libSQL schema",
          "description": "Create a new initial migration that captures the complete database schema compatible with libSQL/SQLite.",
          "dependencies": [
            1,
            2
          ],
          "details": "Implementation steps:\n1. Ensure all SQLAlchemy models have been properly adapted for libSQL/SQLite compatibility\n2. Run the command: `alembic revision --autogenerate -m \"Initial schema for SQLite/libSQL\"`\n3. Capture the new migration version ID for documentation\n4. Verify the migration file was created in the alembic/versions/ directory\n5. Check that the migration includes all expected tables, indices, and constraints\n\nTesting approach:\n- Review the generated migration file to ensure it correctly captures all model definitions\n- Verify no SQLite-incompatible operations are included\n- Check for any unexpected schema differences",
          "status": "done",
          "parentTaskId": 29
        },
        {
          "id": 4,
          "title": "Review and optimize the generated migration",
          "description": "Carefully review the auto-generated migration file and make any necessary adjustments for optimal libSQL compatibility.",
          "dependencies": [
            3
          ],
          "details": "Implementation steps:\n1. Open the newly generated migration file\n2. Review all create_table, create_index, and other schema operations\n3. Check for and fix any SQLite-incompatible operations (like certain constraint types)\n4. Optimize index definitions for libSQL performance characteristics\n5. Add comments explaining any manual adjustments made\n6. Ensure proper handling of TEXT vs VARCHAR types and other SQLite-specific type mappings\n7. Verify foreign key constraints are properly defined\n\nTesting approach:\n- Manually review the SQL that would be generated using 'alembic upgrade --sql head'\n- Verify the SQL is valid for libSQL/SQLite\n- Check for any potential performance issues with the schema design",
          "status": "done",
          "parentTaskId": 29
        },
        {
          "id": 5,
          "title": "Test migration and update documentation",
          "description": "Apply the migration to a test database and update all documentation that references Alembic migrations.",
          "dependencies": [
            3,
            4
          ],
          "details": "Implementation steps:\n1. Create a fresh test libSQL/SQLite database\n2. Apply the migration using 'alembic upgrade head'\n3. Verify all tables, indices, and constraints were created correctly\n4. Update any documentation that references specific migration versions\n5. Update the database setup documentation to reflect the new migration approach\n6. Add a note in the documentation about the migration history reset\n7. Document the process for new installations vs. existing database migrations\n8. Update the switching-db-to-libsql.md document to mark this task as completed\n\nTesting approach:\n- Test the complete database initialization process on a fresh environment\n- Verify application functionality with the new database schema\n- Run database-dependent tests to ensure compatibility\n- Verify documentation accuracy by following it for a new setup",
          "status": "done",
          "parentTaskId": 29
        },
        {
          "id": 6,
          "title": "Adapt existing migrations to use the custom migration tool",
          "description": "Convert the existing migration files to work with the new custom migration tool developed in Task #33.",
          "dependencies": [
            5
          ],
          "details": "Implementation steps:\n1. Review the structure and format required by the new custom migration tool\n2. Convert the initial migration created in subtask 3 to the format required by the custom tool\n3. Ensure all schema definitions are correctly translated to the new format\n4. Verify that all table definitions, indices, and constraints are preserved in the conversion\n5. Update any references to Alembic-specific functions or methods\n\nTesting approach:\n- Verify the converted migration file is valid for the custom migration tool\n- Compare the schema that would be generated by both approaches to ensure equivalence\n- Check for any functionality that might be missing in the conversion",
          "status": "pending",
          "parentTaskId": 29
        },
        {
          "id": 7,
          "title": "Update migration application and rollback procedures",
          "description": "Replace Alembic-specific migration commands with the equivalent commands from the custom migration tool.",
          "dependencies": [
            6
          ],
          "details": "Implementation steps:\n1. Document the commands to apply migrations using the custom migration tool\n2. Document the commands to roll back migrations using the custom migration tool\n3. Update any scripts or documentation that reference 'alembic upgrade' or 'alembic downgrade'\n4. Create examples of common migration scenarios using the new tool\n5. Update CI/CD pipelines to use the new migration commands\n\nTesting approach:\n- Test applying migrations to a fresh database\n- Test rolling back migrations\n- Verify the commands work in all environments (development, testing, production)\n- Ensure the migration state is correctly tracked by the new tool",
          "status": "pending",
          "parentTaskId": 29
        },
        {
          "id": 8,
          "title": "Update developer documentation for the new migration workflow",
          "description": "Create comprehensive documentation for developers on how to use the custom migration tool for all database schema changes.",
          "dependencies": [
            6,
            7
          ],
          "details": "Implementation steps:\n1. Create a new documentation file explaining the custom migration tool workflow\n2. Document how to create new migrations\n3. Document how to apply and roll back migrations\n4. Provide examples of common migration scenarios\n5. Update any existing documentation that references Alembic\n6. Create a migration guide for developers transitioning from Alembic\n7. Document any differences in behavior or capabilities between Alembic and the custom tool\n\nTesting approach:\n- Have another developer follow the documentation to create and apply a test migration\n- Verify all commands and examples work as described\n- Ensure the documentation covers all common migration scenarios",
          "status": "pending",
          "parentTaskId": 29
        },
        {
          "id": 9,
          "title": "Final testing with the custom migration tool",
          "description": "Perform comprehensive testing of the database schema using the custom migration tool.",
          "dependencies": [
            6,
            7,
            8
          ],
          "details": "Implementation steps:\n1. Create a fresh libSQL/SQLite database\n2. Apply the initial migration using the custom migration tool\n3. Verify all tables, indices, and constraints are created correctly\n4. Test the application's functionality with the new database schema\n5. Test the rollback functionality\n6. Verify that the migration state is correctly tracked\n7. Test creating and applying a new migration\n\nTesting approach:\n- Run a full suite of integration tests against the database\n- Verify all CRUD operations work correctly\n- Test complex queries and transactions\n- Ensure the application functions correctly with the new schema\n- Verify migration state tracking works correctly across multiple migrations",
          "status": "pending",
          "parentTaskId": 29
        }
      ]
    },
    {
      "id": 30,
      "title": "Rewrite Database Schema and Seed Scripts for SQLite Compatibility",
      "description": "Rewrite the database initialization schema and adapt the admin seeding script to be compatible with SQLite syntax, following the guidelines in the documentation.",
      "details": "This task involves rewriting the `database/init_schema.sql` file to use SQLite syntax and adapting the `scripts/seed_admin.py` script as needed. The changes should follow section 5 of `docs/switching-db-to-libsql.md`.\n\nFor `init_schema.sql`:\n1. Replace PostgreSQL-specific data types with SQLite equivalents\n2. Change primary key definitions to use `INTEGER PRIMARY KEY AUTOINCREMENT` syntax\n3. Adjust the `INSERT INTO Roles` statements to match SQLite syntax\n4. Ensure all table creation statements are SQLite-compatible\n5. Verify that any constraints or indexes are properly defined for SQLite\n\nFor `scripts/seed_admin.py`:\n1. Review the script to identify any PostgreSQL-specific SQLAlchemy code\n2. Update the script to work with the SQLite dialect if necessary\n3. Ensure it correctly interacts with the updated SQLAlchemy models\n4. Test that it can successfully create an admin user in the SQLite database\n\nThe implementation should maintain all existing functionality while ensuring compatibility with SQLite/libSQL. Pay special attention to data type conversions, auto-increment behavior, and any SQL syntax differences between PostgreSQL and SQLite.",
      "testStrategy": "1. Execute the rewritten `init_schema.sql` against a fresh SQLite database and verify it runs without errors\n2. Validate the database schema by inspecting the created tables using SQLite CLI or a GUI tool:\n   - Check that all tables have the correct structure\n   - Verify primary keys are properly set up with autoincrement\n   - Confirm that all indexes and constraints are present\n3. Run the adapted `seed_admin.py` script and verify:\n   - It executes without errors\n   - An admin user is successfully created in the database\n   - The user has the correct role and permissions\n4. Perform basic application operations that interact with the database to ensure the schema changes don't break functionality\n5. Write a simple test script that performs CRUD operations on each table to verify the schema works as expected\n6. Document any SQLite-specific limitations or behavior differences that developers should be aware of",
      "status": "done",
      "dependencies": [
        29
      ],
      "priority": "medium",
      "subtasks": [
        {
          "id": 1,
          "title": "Analyze PostgreSQL Schema and Identify SQLite Conversion Requirements",
          "description": "Review the existing PostgreSQL schema in `database/init_schema.sql` and document all elements that need conversion to SQLite syntax",
          "dependencies": [],
          "details": "Implementation steps:\n1. Examine the current `database/init_schema.sql` file and identify all PostgreSQL-specific data types and syntax\n2. Create a mapping document that lists each PostgreSQL data type/feature and its SQLite equivalent\n3. Document specific changes needed for:\n   - Data type conversions (e.g., SERIAL to INTEGER PRIMARY KEY AUTOINCREMENT)\n   - Primary key definitions\n   - Foreign key constraints\n   - Default values\n   - INSERT statements\n   - Any other PostgreSQL-specific features\n4. Review section 5 of `docs/switching-db-to-libsql.md` to ensure all requirements are captured\n5. Create a checklist of all required changes to guide implementation\n\nTesting approach:\n- Verify the completeness of the analysis by cross-checking with SQLite documentation\n- Ensure all tables and fields in the original schema are accounted for in the conversion plan",
          "status": "done",
          "parentTaskId": 30
        },
        {
          "id": 2,
          "title": "Rewrite Table Creation Statements for SQLite Compatibility",
          "description": "Modify all CREATE TABLE statements in the schema file to use SQLite-compatible syntax",
          "dependencies": [
            1
          ],
          "details": "Implementation steps:\n1. Create a new version of `database/init_schema.sql` based on the analysis from subtask 1\n2. Convert all table creation statements to use SQLite syntax:\n   - Replace PostgreSQL data types with SQLite equivalents (e.g., TEXT instead of VARCHAR, INTEGER instead of INT)\n   - Change SERIAL/BIGSERIAL primary keys to INTEGER PRIMARY KEY AUTOINCREMENT\n   - Adjust foreign key constraint syntax if needed\n   - Modify default value syntax to be SQLite-compatible\n3. Ensure all table relationships and constraints are preserved\n4. Add appropriate comments to document significant changes\n\nTesting approach:\n- Run the modified schema file against a test SQLite database to verify syntax\n- Check that all tables are created without errors\n- Verify primary key and foreign key constraints are properly defined",
          "status": "done",
          "parentTaskId": 30
        },
        {
          "id": 3,
          "title": "Update INSERT Statements and Role Definitions for SQLite",
          "description": "Modify all INSERT statements and role definitions in the schema file to be compatible with SQLite syntax",
          "dependencies": [
            2
          ],
          "details": "Implementation steps:\n1. Review all INSERT statements in the original schema file, particularly for the Roles table\n2. Adjust the syntax of INSERT statements to be SQLite-compatible:\n   - Modify value formats if necessary\n   - Ensure proper quoting of string values\n   - Adjust any sequence or auto-increment references\n3. If the original schema uses any PostgreSQL-specific INSERT features (like RETURNING), replace with SQLite alternatives\n4. Verify that all predefined data (like role definitions) are properly inserted\n\nTesting approach:\n- Execute the INSERT statements against a test SQLite database\n- Query the database to verify that all predefined data was correctly inserted\n- Check that role IDs and other values match the expected values from the original schema",
          "status": "done",
          "parentTaskId": 30
        },
        {
          "id": 4,
          "title": "Analyze and Update SQLAlchemy Models in seed_admin.py",
          "description": "Review and modify the SQLAlchemy models and database interaction code in the admin seeding script",
          "dependencies": [
            1
          ],
          "details": "Implementation steps:\n1. Examine `scripts/seed_admin.py` to identify any PostgreSQL-specific SQLAlchemy code\n2. Update SQLAlchemy model definitions if they contain PostgreSQL-specific types or features:\n   - Replace PostgreSQL-specific column types with SQLite-compatible types\n   - Update sequence or auto-increment definitions\n   - Modify any dialect-specific options\n3. Check database connection code to ensure it can connect to SQLite databases\n4. Update any raw SQL queries to use SQLite syntax\n5. Ensure the script correctly references the updated model definitions\n\nTesting approach:\n- Run static code analysis to check for syntax errors\n- Test the script with a mock SQLite database connection\n- Verify that SQLAlchemy models match the updated schema structure",
          "status": "done",
          "parentTaskId": 30
        },
        {
          "id": 5,
          "title": "Test and Finalize SQLite Compatibility",
          "description": "Perform comprehensive testing of the updated schema and seeding script with SQLite",
          "dependencies": [
            2,
            3,
            4
          ],
          "details": "Implementation steps:\n1. Set up a test SQLite database\n2. Execute the updated `init_schema.sql` script against the test database\n3. Run the modified `seed_admin.py` script to create an admin user\n4. Verify that all database operations work as expected:\n   - Tables are created with correct structure\n   - Foreign key constraints work properly\n   - Auto-increment fields generate correct values\n   - Admin user is created successfully\n5. Make any final adjustments to the schema or script based on testing results\n6. Update documentation to reflect the changes made\n\nTesting approach:\n- Run a full end-to-end test of database initialization and admin seeding\n- Verify database structure using SQLite tools (like sqlite3 CLI or DB Browser for SQLite)\n- Test CRUD operations on the admin user to ensure compatibility\n- Compare the behavior with the original PostgreSQL implementation to ensure functional equivalence",
          "status": "done",
          "parentTaskId": 30
        }
      ]
    },
    {
      "id": 31,
      "title": "Remove Fernet/EncryptedType Field Encryption from Codebase",
      "description": "Remove application-level field encryption (Fernet/EncryptedType) from all models and code since database security is now handled by libSQL TDE and TLS connections.",
      "details": "This task involves removing all application-level field encryption that's no longer needed due to database-level encryption:\n\n1. Identify all SQLAlchemy models using EncryptedType fields\n2. Convert these fields to their base types (String, Integer, etc.)\n3. Remove all imports and usage of Fernet and EncryptedType throughout the codebase\n4. Update database migration scripts to convert encrypted columns to plain data types\n5. Remove encryption-related utility functions and helper methods\n6. Update any API endpoints or services that handle encryption/decryption logic\n7. Remove encryption-related environment variables (ENCRYPTION_KEY, etc.) from:\n   - .env files\n   - Docker configurations\n   - CI/CD pipelines\n   - Deployment templates\n8. Update documentation to reflect that field-level encryption has been removed and security is now handled at the database level\n9. Ensure any data serialization/deserialization logic that handled encrypted fields is updated\n10. Check for any custom validation logic that might have been specific to encrypted fields\n\nBefore making changes, create a backup of the database to ensure data can be recovered if needed.",
      "testStrategy": "1. Create a comprehensive test plan covering all affected models and functionality:\n   - Unit tests: Verify models function correctly with plain field types\n   - Integration tests: Ensure API endpoints correctly handle the non-encrypted data\n   - Migration tests: Verify data integrity after migration from encrypted to non-encrypted fields\n\n2. Specific test cases:\n   - Test CRUD operations on all previously encrypted fields\n   - Verify data consistency by comparing pre-migration and post-migration data samples\n   - Test boundary conditions (empty values, max length values, special characters)\n   - Ensure search functionality works on previously encrypted fields\n   - Verify that removing encryption doesn't break any filtering or sorting operations\n\n3. Security validation:\n   - Confirm TLS connections are properly configured\n   - Verify libSQL TDE is correctly protecting the database\n   - Run security scans to ensure no sensitive data is exposed\n\n4. Performance testing:\n   - Measure and document any performance improvements from removing encryption overhead\n\n5. Regression testing:\n   - Run the full test suite to ensure no functionality is broken by these changes",
      "status": "done",
      "dependencies": [],
      "priority": "medium",
      "subtasks": [
        {
          "id": 1,
          "title": "Audit and inventory all encrypted fields in models",
          "description": "Create a comprehensive inventory of all SQLAlchemy models using EncryptedType fields, documenting their current types, encryption methods, and where they're used in the codebase.",
          "dependencies": [],
          "details": "Implementation steps:\n1. Search the codebase for all imports of 'EncryptedType' and 'Fernet'\n2. Identify all model classes using these imports\n3. For each model, document:\n   - Model name\n   - Encrypted field names\n   - Base data types (String, Integer, etc.)\n   - Any special handling or validation logic\n4. Create a mapping document showing current encrypted fields and their target plain types\n5. Identify any custom encryption/decryption utility functions\n\nTesting approach:\n- This is an audit task, so verify completeness by using grep/search tools\n- Cross-reference findings with database schema to ensure all encrypted columns are identified",
          "status": "done",
          "parentTaskId": 31
        },
        {
          "id": 2,
          "title": "Create database migration script for decryption",
          "description": "Develop a database migration script that will safely convert encrypted column data to plaintext while preserving the original information.",
          "dependencies": [
            1
          ],
          "details": "Implementation steps:\n1. Create a new Alembic migration script\n2. For each encrypted field identified in subtask 1:\n   - Add migration code to decrypt the data in-place\n   - Modify column types to remove encryption\n   - Ensure proper data type conversion\n3. Include transaction handling for safety\n4. Add rollback capability in case of failure\n5. Test the migration on a copy of production data\n6. Document the migration process\n\nTesting approach:\n- Test migration on a copy of the database\n- Verify data integrity by comparing decrypted values with expected values\n- Test rollback functionality\n- Ensure all data types are correctly preserved",
          "status": "done",
          "parentTaskId": 31
        },
        {
          "id": 3,
          "title": "Update SQLAlchemy models to remove EncryptedType",
          "description": "Modify all SQLAlchemy model definitions to replace EncryptedType fields with their base types (String, Integer, etc.).",
          "dependencies": [
            1,
            2
          ],
          "details": "Implementation steps:\n1. For each model identified in subtask 1:\n   - Replace EncryptedType fields with their base types\n   - Remove Fernet and EncryptedType imports\n   - Update any type hints or annotations\n2. Update model validation methods that might reference encryption\n3. Update any model methods that handle encryption/decryption\n4. Remove any special handling for encrypted fields in model methods\n5. Update model tests to reflect the changes\n\nTesting approach:\n- Run unit tests for all modified models\n- Test CRUD operations with the updated models\n- Verify serialization/deserialization still works correctly\n- Ensure model validation still functions properly",
          "status": "done",
          "parentTaskId": 31
        },
        {
          "id": 4,
          "title": "Update service layer and API endpoints",
          "description": "Modify service layer code and API endpoints to remove any encryption/decryption logic and handle plaintext data directly.",
          "dependencies": [
            3
          ],
          "details": "Implementation steps:\n1. Identify all services and API endpoints that interact with previously encrypted fields\n2. Remove any encryption/decryption operations in these components\n3. Update data validation logic that might have been specific to encrypted fields\n4. Update serialization/deserialization logic for API responses\n5. Remove any special handling for encrypted fields in business logic\n6. Update error handling related to encryption/decryption\n\nTesting approach:\n- Run unit tests for all modified services\n- Test API endpoints with various inputs\n- Verify correct data handling without encryption\n- Test edge cases that might have been handled differently with encryption",
          "status": "done",
          "parentTaskId": 31
        },
        {
          "id": 5,
          "title": "Remove encryption utilities and environment variables",
          "description": "Clean up all encryption-related utility functions, helper methods, and environment variables from the codebase and configuration files.",
          "dependencies": [
            3,
            4
          ],
          "details": "Implementation steps:\n1. Remove all encryption utility functions and helper methods\n2. Delete encryption-related environment variables from:\n   - .env files and templates\n   - Docker configurations\n   - CI/CD pipeline configurations\n   - Deployment templates\n   - Kubernetes/infrastructure configs\n3. Update configuration loading code to remove references to encryption keys\n4. Remove any encryption-related test fixtures or mocks\n5. Clean up imports of removed utilities throughout the codebase\n\nTesting approach:\n- Verify application starts without encryption environment variables\n- Run the test suite to ensure no references to removed utilities\n- Check deployment processes work without encryption configuration\n- Verify no runtime errors occur due to missing encryption utilities",
          "status": "done",
          "parentTaskId": 31
        },
        {
          "id": 6,
          "title": "Update documentation and finalize removal",
          "description": "Update all documentation to reflect the removal of field-level encryption and perform final verification that all encryption code has been removed.",
          "dependencies": [
            1,
            2,
            3,
            4,
            5
          ],
          "details": "Implementation steps:\n1. Update documentation to reflect that field-level encryption has been removed\n2. Document that security is now handled at the database level (libSQL TDE and TLS)\n3. Update developer guides, API documentation, and security documentation\n4. Perform a final codebase search for any remaining references to:\n   - Fernet\n   - EncryptedType\n   - Encryption keys\n   - Encryption/decryption functions\n5. Run a full test suite to verify application functionality\n6. Update any data seeding scripts or fixtures that might have used encrypted data\n\nTesting approach:\n- Comprehensive end-to-end testing of the application\n- Verify all documentation accurately reflects the new security approach\n- Run security scans to ensure no sensitive data is exposed\n- Verify all tests pass with the updated codebase",
          "status": "done",
          "parentTaskId": 31
        }
      ]
    },
    {
      "id": 32,
      "title": "Implement Subscription Pricing Plans with Feature Gating",
      "description": "Create a tiered pricing structure with feature access control based on subscription plans. Integrate with the existing Stripe payment processing system to handle plan selection, upgrades, and downgrades.",
      "details": "This task requires implementing a comprehensive subscription plan system:\n\n1. Database Changes:\n   - Create a new `Plans` table with fields: `id`, `name` (Basic, Pro, Enterprise), `price`, `billing_frequency` (monthly/annual), `features` (JSON field storing allowed features), `stripe_price_id`, `created_at`, `updated_at`\n   - Add `current_plan_id` (foreign key to Plans table) and `subscription_status` fields to the `Office` table\n\n2. Feature Gating Implementation:\n   - Create a centralized FeatureAccess service class that handles all permission checks\n   - Implement methods like `canAccessFeature(officeId, featureName)` that check if an office's plan includes specific features\n   - Create middleware for protecting routes based on subscription level\n   - Add UI indicators for premium features\n\n3. Stripe Integration:\n   - Map internal plan IDs to Stripe product/price IDs\n   - Implement plan change functionality (upgrades/downgrades)\n   - Handle prorated billing for mid-cycle changes\n   - Update webhook handlers to process subscription events\n\n4. Admin Interface:\n   - Create admin tools to manage plans and their features\n   - Add ability to view and modify customer subscriptions\n\n5. User Experience:\n   - Implement plan selection during signup\n   - Create plan comparison page\n   - Add upgrade prompts when users attempt to access premium features\n\nRefer to docs/payment-plan.md for the specific billing structure and feature sets for each plan tier. Ensure all plan-related logic is centralized for easy updates to pricing or feature sets.",
      "testStrategy": "Testing should cover all aspects of the subscription system:\n\n1. Unit Tests:\n   - Test FeatureAccess service with various plan/feature combinations\n   - Verify plan upgrade/downgrade logic handles all edge cases\n   - Test proration calculations\n\n2. Integration Tests:\n   - Verify Stripe API interactions for subscription creation, updates, and cancellations\n   - Test webhook handling for subscription events\n   - Ensure database updates correctly when plan changes occur\n\n3. End-to-End Tests:\n   - Complete user journeys: signup with plan selection, upgrade flow, downgrade flow\n   - Verify feature access is properly restricted based on plan\n   - Test plan change with billing implications\n\n4. Manual Testing:\n   - Use Stripe test mode to verify complete subscription lifecycle\n   - Verify UI elements correctly show/hide based on subscription status\n   - Test upgrade prompts when accessing gated features\n\n5. Edge Cases:\n   - Test subscription cancellation and reinstatement\n   - Verify handling of failed payments\n   - Test plan changes near billing cycle boundaries\n\nCreate a test matrix covering all features and their availability in each plan tier to ensure comprehensive coverage.",
      "status": "pending",
      "dependencies": [
        9
      ],
      "priority": "medium",
      "subtasks": [
        {
          "id": 1,
          "title": "Design and Implement Plans Table",
          "description": "Create a Plans table to define available pricing tiers (e.g., Basic, Pro, Enterprise), their prices, billing intervals, and included features. Ensure the table structure supports easy addition or modification of plans.",
          "details": "",
          "status": "pending",
          "dependencies": [],
          "parentTaskId": 32
        },
        {
          "id": 2,
          "title": "Add current_plan_id Field to Office Table",
          "description": "Add a current_plan_id field to the Office table to reference the selected plan for each office. Ensure this field is properly indexed and supports plan upgrades/downgrades.",
          "details": "",
          "status": "pending",
          "dependencies": [],
          "parentTaskId": 32
        },
        {
          "id": 3,
          "title": "Implement Feature Gating Logic Based on Plan",
          "description": "Centralize logic to check feature access based on the office's current plan. Use decorators, middleware, or service-layer checks to enforce plan-based feature access throughout the app.",
          "details": "",
          "status": "pending",
          "dependencies": [],
          "parentTaskId": 32
        },
        {
          "id": 4,
          "title": "Integrate Plan Selection and Upgrades/Downgrades with Billing and Stripe",
          "description": "Implement endpoints and business logic for offices to select, upgrade, or downgrade their plan. Ensure changes are reflected in Stripe (or other payment provider) and that billing is prorated or adjusted as needed.",
          "details": "",
          "status": "pending",
          "dependencies": [],
          "parentTaskId": 32
        },
        {
          "id": 5,
          "title": "Document Plan and Feature Gating System",
          "description": "Update developer and user documentation to describe available plans, included features, and how feature gating is enforced. Reference docs/payment-plan.md and ensure documentation is clear for future maintenance.",
          "details": "",
          "status": "pending",
          "dependencies": [],
          "parentTaskId": 32
        }
      ]
    },
    {
      "id": 33,
      "title": "Task #33: Develop Custom Database Migration Tool for libSQL",
      "description": "Create a custom database migration tool that interfaces with libSQL to manage schema changes, supporting version control of database structure with capabilities to apply, rollback, and track migrations.",
      "details": "The migration tool should be implemented as a standalone CLI utility that interfaces directly with our libSQL database. Key requirements include:\n\n1. **Migration Creation**: Provide a command to generate new migration files with timestamps for ordering (e.g., `20230615120000_add_user_table.sql`).\n\n2. **Migration Structure**: Each migration should contain both \"up\" (apply) and \"down\" (rollback) SQL scripts.\n\n3. **Migration Tracking**: Create a migrations table in the database to track which migrations have been applied, including timestamp, name, and execution status.\n\n4. **Core Commands**:\n   - `migrate:status` - Show current migration state\n   - `migrate:up` - Apply all pending migrations\n   - `migrate:up --step=N` - Apply N pending migrations\n   - `migrate:down` - Rollback the most recent migration\n   - `migrate:down --step=N` - Rollback N most recent migrations\n   - `migrate:create NAME` - Create a new migration file\n\n5. **Error Handling**: Implement transaction support to ensure migrations are atomic - either fully applied or fully rolled back.\n\n6. **Compatibility**: Ensure compatibility with libSQL's specific features and syntax differences from standard SQLite.\n\n7. **Integration**: The tool should be easily invokable from our CI/CD pipeline and development environments.\n\n8. **Documentation**: Include comprehensive documentation on how to use the tool, create migrations, and troubleshoot common issues.\n\n9. **Configuration**: Support configuration via environment variables and/or config files for database connection details.\n\n10. **Logging**: Implement detailed logging of all migration operations for debugging and audit purposes.\n\nConsider using a language that's already common in our stack for implementation. The tool should be designed with our specific libSQL implementation in mind, particularly considering the changes made in Task #30 for SQLite compatibility.",
      "testStrategy": "Testing for the migration tool should be comprehensive and include:\n\n1. **Unit Tests**:\n   - Test each command function independently with mocked database connections\n   - Verify proper file generation for new migrations\n   - Test parsing and validation of migration files\n   - Verify proper ordering of migrations based on timestamps\n\n2. **Integration Tests**:\n   - Set up a test libSQL database instance\n   - Test the full migration lifecycle:\n     - Create multiple migrations\n     - Apply them in sequence\n     - Verify database schema changes\n     - Roll back migrations\n     - Verify schema returns to previous states\n   - Test error scenarios (e.g., conflicting migrations, syntax errors)\n   - Test the migrations table structure and content after operations\n\n3. **Edge Cases**:\n   - Test behavior when migrations are applied out of order\n   - Test handling of failed migrations\n   - Test recovery from interrupted migrations\n   - Test with very large migration files\n   - Test concurrent migration attempts\n\n4. **Manual Testing Checklist**:\n   - Verify all CLI commands work as expected\n   - Test integration with actual project database\n   - Verify logging output is clear and useful\n   - Test on all supported development environments\n\n5. **CI Integration**:\n   - Add automated tests to CI pipeline\n   - Create a test that verifies migrations can be applied to a clean database\n\n6. **Documentation Verification**:\n   - Ensure all commands are properly documented\n   - Verify examples in documentation work as described\n\nThe testing should verify that the tool can safely manage our database schema across development, staging, and production environments without data loss or corruption.",
      "status": "pending",
      "dependencies": [],
      "priority": "medium",
      "subtasks": [
        {
          "id": 1,
          "title": "Design CLI structure and command interface",
          "description": "Define the command-line interface structure, argument parsing, and command handlers for the migration tool.",
          "dependencies": [],
          "details": "Implement the core CLI structure using a library like Commander.js or Click (Python). Define all required commands (migrate:status, migrate:up, migrate:down, migrate:create) with their respective options and help documentation. Set up the basic project structure, including entry point, command routing, and help text generation.\n<info added on 2025-05-20T21:12:18.197Z>\nImplement the core CLI structure using a modern CLI library such as Commander.js (Node.js), Click (Python), or Typer (Python). External dependencies are recommended for this task to provide a more robust, user-friendly, and maintainable command-line interface. These libraries offer significant advantages in argument parsing, help text generation, command routing, and error handling.\n\nDefine all required commands (migrate:status, migrate:up, migrate:down, migrate:create) with their respective options and comprehensive help documentation. The chosen library should facilitate better UX through clear error messages, command suggestions, and auto-generated help text.\n\nSet up the basic project structure, including entry point, command routing, and help text generation, leveraging the CLI library's features for extensibility and maintainability.\n\nDocument all external dependencies in requirements.txt (Python) or package.json (Node.js) with specific version requirements to ensure reproducible builds.\n</info added on 2025-05-20T21:12:18.197Z>",
          "status": "pending",
          "testStrategy": "Write unit tests for command parsing and routing logic. Test each command with various argument combinations to ensure correct behavior."
        },
        {
          "id": 2,
          "title": "Implement migration file template and creation",
          "description": "Create functionality to generate new migration files with proper timestamps and structure for up/down operations.",
          "dependencies": [
            1
          ],
          "details": "Implement the migrate:create command to generate migration files with timestamp prefixes (e.g., 20230615120000_add_user_table.sql). Create templates for migrations that include sections for 'up' and 'down' SQL scripts. Ensure proper file naming, validation, and placement in a designated migrations directory.",
          "status": "pending",
          "testStrategy": "Test file creation with various migration names, verify timestamp format, file structure, and content template."
        },
        {
          "id": 3,
          "title": "Develop database connection and configuration module",
          "description": "Create a module to handle database connections and configuration management for the migration tool.",
          "dependencies": [
            1
          ],
          "details": "Implement configuration loading from environment variables and/or config files. Create a database connection module that interfaces with libSQL, handling connection pooling, retries, and error states. Support different environments (development, testing, production) with appropriate connection parameters.",
          "status": "pending",
          "testStrategy": "Test configuration loading from different sources, connection establishment, error handling, and connection pool management."
        },
        {
          "id": 4,
          "title": "Create migrations tracking table and schema",
          "description": "Design and implement the database schema for tracking applied migrations.",
          "dependencies": [
            3
          ],
          "details": "Create a migrations table in the database with columns for migration ID, name, timestamp, applied_at, and status. Implement functions to initialize this table if it doesn't exist. Ensure the table can properly track the state of all migrations that have been applied or rolled back.",
          "status": "pending",
          "testStrategy": "Test table creation, schema validation, and basic operations for recording migration status."
        },
        {
          "id": 5,
          "title": "Implement migration status reporting",
          "description": "Develop the migrate:status command to show the current state of all migrations.",
          "dependencies": [
            3,
            4
          ],
          "details": "Implement logic to scan the migrations directory, compare with the migrations table, and report which migrations are pending, applied, or rolled back. Format the output in a clear, tabular format showing timestamps, names, and statuses. Include summary statistics (e.g., '5 of 10 migrations applied').",
          "status": "pending",
          "testStrategy": "Test with various combinations of applied and pending migrations. Verify correct status reporting and formatting."
        },
        {
          "id": 6,
          "title": "Implement migration up logic with transaction support",
          "description": "Develop the core functionality to apply pending migrations with transaction support.",
          "dependencies": [
            3,
            4
          ],
          "details": "Implement the migrate:up command to apply pending migrations in timestamp order. Support the --step=N option to limit the number of migrations applied. Wrap each migration in a transaction to ensure atomicity. Parse and execute the 'up' portion of each migration file. Update the migrations table to reflect successful applications.",
          "status": "pending",
          "testStrategy": "Test applying single and multiple migrations, transaction rollback on error, and step limiting. Verify migrations table is correctly updated."
        },
        {
          "id": 7,
          "title": "Implement migration down logic with rollback support",
          "description": "Develop functionality to roll back applied migrations in reverse order.",
          "dependencies": [
            6
          ],
          "details": "Implement the migrate:down command to roll back the most recent migration(s). Support the --step=N option to control how many migrations to roll back. Parse and execute the 'down' portion of each migration file. Update the migrations table to reflect successful rollbacks. Include safeguards to prevent accidental rollback of all migrations.",
          "status": "pending",
          "testStrategy": "Test rolling back single and multiple migrations, transaction handling, and step limiting. Verify migrations table is correctly updated after rollbacks."
        },
        {
          "id": 8,
          "title": "Implement logging and error handling system",
          "description": "Create a comprehensive logging and error handling system for the migration tool.",
          "dependencies": [
            6,
            7
          ],
          "details": "Implement structured logging for all operations with configurable verbosity levels. Log migration attempts, successes, failures, and SQL errors. Create specific error types for different failure scenarios (connection issues, SQL errors, file system errors). Implement graceful error handling with helpful error messages and suggested remediation steps.",
          "status": "pending",
          "testStrategy": "Test logging output at different verbosity levels. Simulate various error conditions and verify appropriate error handling and messaging."
        },
        {
          "id": 9,
          "title": "Create comprehensive documentation",
          "description": "Develop user and developer documentation for the migration tool.",
          "dependencies": [
            1,
            2,
            5,
            6,
            7,
            8
          ],
          "details": "Create comprehensive documentation including: installation guide, command reference with examples, migration file format specification, configuration options, troubleshooting guide, and developer documentation for extending the tool. Include examples of common migration patterns and best practices.",
          "status": "pending",
          "testStrategy": "Review documentation for completeness and accuracy. Test following the documentation to perform common tasks to ensure it's correct and comprehensive."
        },
        {
          "id": 10,
          "title": "Implement CI/CD integration and deployment",
          "description": "Create scripts and configurations for integrating the migration tool with CI/CD pipelines.",
          "dependencies": [
            6,
            7,
            8
          ],
          "details": "Develop scripts for running migrations in CI/CD environments. Create Docker configuration for containerized usage. Implement safeguards for production environments (confirmation prompts, dry-run mode). Create example configurations for common CI/CD platforms (GitHub Actions, Jenkins, etc.). Ensure the tool can be easily invoked from automated deployment processes.",
          "status": "pending",
          "testStrategy": "Test integration with at least one CI/CD platform. Verify migrations can be applied automatically during deployment. Test safeguards for production environments."
        },
        {
          "id": 11,
          "title": "Remove all Alembic code and references from the project",
          "description": "Delete all Alembic-related code, configuration files, migration scripts, and references from the codebase. This includes removing the alembic/ directory, alembic.ini, any Alembic imports/usages in Python files, and updating documentation to reflect the removal. Ensure no Alembic-specific logic remains and that all migration instructions now reference the new custom migration tool.",
          "details": "1. Delete the alembic/ directory and all its contents.\n2. Remove alembic.ini from the project root.\n3. Search for and remove all Alembic imports/usages in the codebase (e.g., in api/database, models, or scripts).\n4. Update any documentation (README, docs/, etc.) to remove or replace Alembic references with the new migration tool.\n5. Ensure no Alembic-specific logic remains in any scripts or CI/CD configs.\n6. Verify that all migration instructions and developer onboarding reference the new tool only.",
          "status": "pending",
          "dependencies": [],
          "parentTaskId": 33
        }
      ]
    }
  ],
  "metadata": {
    "projectName": "Chiropractic Practice Management System",
    "totalTasks": 20,
    "sourceFile": "/Users/jchristman/dev/tirado-chiro-app/docs/prd.md",
    "generatedAt": "2023-11-10"
  }
}